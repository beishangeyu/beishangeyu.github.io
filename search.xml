<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1786B/</url>
    <content><![CDATA[<h1 id="Cake-Assembly-Line"><a href="#Cake-Assembly-Line" class="headerlink" title="Cake Assembly Line"></a>Cake Assembly Line</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有一个无限长的传送带，传送带上有 $n$ 个蛋糕，天花板上有 $n$ 个喷嘴。一开始每个蛋糕中心的位置是 $a_i$，宽度是 $2w$（也就是这个蛋糕占据的空间是 $[a_i-w,a_i+w]$）；每个喷嘴中心位置是 $b_i$，宽度是 $2h$。</p>
<p>你可以随意移动传动带，但蛋糕间的相对位置不会改变，并且喷嘴的位置也不会发生变化。问能不能通过转动传送带的方式，使得每个喷嘴下面都有一个蛋糕，每个蛋糕上面都有一个喷嘴，并且喷嘴挤出的奶油不会掉到传动带上。</p>
<p>多组数据。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A cake assembly line in a bakery was once again optimized, and now $ n $ cakes are made at a time! In the last step, each of the $ n $ cakes should be covered with chocolate.</p>
<p>Consider a side view on the conveyor belt, let it be a number line. The $ i $ -th cake occupies the segment $ [a_i - w, a_i + w] $ on this line, each pair of these segments does not have common points. Above the conveyor, there are $ n $ dispensers, and when a common button is pressed, chocolate from the $ i $ -th dispenser will cover the conveyor segment $ [b_i - h, b_i + h] $ . Each pair of these segments also does not have common points.</p>
<p>Cakes and dispensers corresponding to the first example.The calibration of this conveyor belt part has not yet been performed, so you are to make it. Determine if it’s possible to shift the conveyor so that each cake has some chocolate on it, and there is no chocolate outside the cakes. You can assume that the conveyour is long enough, so the cakes never fall. Also note that the button can only be pressed once.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^5 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains three integers $ n $ , $ w $ , and $ h $ ( $ 1 \le n \le 10^5 $ ; $ 1 \le w, h \le 10^5 $ ; $ h \le w $ ) — the number of cakes and dispensers, as well as the halfwidths of cakes and segments on which the chocolate is dispensed.</p>
<p>The second line contains $ n $ integers $ a_1 $ , $ a_2 $ , …, $ a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the positions of the cakes centers. It is guaranteed that $ a_i + w &lt; a_{i + 1} - w $ for all $ i $ .</p>
<p>The third line contains $ n $ integers $ b_1 $ , $ b_2 $ , …, $ b_n $ ( $ 1 \le b_i \le 10^9 $ ) — the positions of the dispensers. It is guaranteed that $ b_i + h &lt; b_{i + 1} - h $ for all $ i $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case output “YES”, if it’s possible to shift the conveyor in such a way that each cake ends up with some chocolate, and no chocolate is outside the cakes, and “NO” otherwise.</p>
<p>You can output the answer in any case (upper or lower). For example, the strings “yEs”, “yes”, “Yes”, and “YES” will be recognized as positive responses.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">10</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">65 </span><span class="number">95</span> <span class="number">165</span></span><br><span class="line"><span class="symbol">40 </span><span class="number">65</span> <span class="number">145</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">6</span> <span class="number">11</span> <span class="number">16</span> <span class="number">21</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">9</span> <span class="number">14</span> <span class="number">19</span> <span class="number">24</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">22</span> <span class="number">29</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">16</span> <span class="number">25</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">27 </span><span class="number">36</span> <span class="number">127</span> <span class="number">136</span></span><br><span class="line"><span class="symbol">35 </span><span class="number">50</span> <span class="number">141</span> <span class="number">144</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我一开始担心说会不会不是一个蛋糕对应一个喷嘴, 也就是会不会有一个蛋糕的一部分和另一个蛋糕的一部分被同一个喷嘴占用</p>
<p>但是我们要注意题目说了, 任意两个蛋糕的区间没有相同的点, 也就是说相邻两个蛋糕, 前一个右边界和后一个的左边界之间至少空了1, 如果这两个占用一个喷头, 那肯定会有巧克力没有喷在蛋糕上</p>
<p>所以我们可以明确了, 一个蛋糕占用一个喷嘴, 那么一对对应了的蛋糕的喷嘴之间会有什么关系呢? 一个蛋糕再怎么移动, 他的左边界也不能超过对应喷嘴的左边界, 不然巧克力就会洒出来, 而且蛋糕的右边界应该大于等于对应喷嘴的左边界, 要达到右边界的要求, 我们肯定希望位移尽可能大, 越大越容易满足</p>
<p>所以我们可以考虑蛋糕最多可以往右移动多少, 这个是由喷嘴和蛋糕的左边界决定的, 记为k, 为了使所有蛋糕移动都合法, 我们要找出所有蛋糕中k的最小值, 并对所有蛋糕向右移动k的距离, 然后我们遍历右边界, 看是否合法, 如果所有蛋糕在左边界合法的情况下向右移动了最大的距离时, 右边界仍有不合法, 此时就肯定无解, 反之就有解</p>
<p>这种解法的时间复杂度是 $O(n)$, 是 $10^5$ </p>
<p><strong>!</strong>: 因为数组元素到了 $10^9$ 量级, 保险起见我们开long long去存</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll cake[N], cho[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		ll n, w, h; cin &gt;&gt; n &gt;&gt; w &gt;&gt; h;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; cake[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; cho[i];</span><br><span class="line">		ll minn = <span class="number">1e9</span>;	<span class="comment">//最多能向右移动多少</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			minn = <span class="built_in">min</span>(minn, cho[i] - h - (cake[i] - w));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll t = cake[i] + w + minn;</span><br><span class="line">			<span class="keyword">if</span>(t &lt; cho[i] + h)	<span class="comment">//还不能满足就是无解了</span></span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="literal">false</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1784A/</url>
    <content><![CDATA[<h1 id="Monsters-easy-version"><a href="#Monsters-easy-version" class="headerlink" title="Monsters (easy version)"></a>Monsters (easy version)</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>你正在打游戏。</p>
<p>现在有 $n$ 只怪物，第 $i$ 只有 $a_i$ 点血。</p>
<p>你当然要把它们打死。你有两种攻击方式：</p>
<ol>
<li>选取任意一只怪物，扣除它 $1$ 点血。这种攻击方式可以无限次使用。</li>
<li>使所有怪物各扣除 $1$ 点血，如果有怪物被这次攻击「杀死」了，就立即再进行一次这种攻击。<strong>注意，这种攻击方式每局只能用一次。</strong></li>
</ol>
<p>其中，「杀死」一只怪物需要让它的血量小于等于 $0$。被「杀死」的怪物立即退出游戏。</p>
<p>你要求出「杀死」所有怪物使用攻击方式 1 的最小次数。</p>
<p><strong>本题有多组数据。</strong></p>
<p>第一行，一个整数 $t(t\leq10^4)$，代表数据组数。</p>
<p>每组数据包含两行。第一行，一个整数 $n$，代表怪物数。第二行，$n$ 个整数 $a_i$，代表每只怪物的血量。</p>
<p>保证 $1\leq n\leq2\cdot10^5,\sum n\leq 2\cdot10^5,1\leq a_i\leq n$。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>This is the easy version of the problem. In this version, you only need to find the answer once. In this version, hacks are not allowed.</p>
<p>In a computer game, you are fighting against $ n $ monsters. Monster number $ i $ has $ a_i $ health points, all $ a_i $ are integers. A monster is alive while it has at least $ 1 $ health point.</p>
<p>You can cast spells of two types:</p>
<ol>
<li>Deal $ 1 $ damage to any single alive monster of your choice.</li>
<li>Deal $ 1 $ damage to all alive monsters. If at least one monster dies (ends up with $ 0 $ health points) as a result of this action, then repeat it (and keep repeating while at least one monster dies every time).</li>
</ol>
<p>Dealing $ 1 $ damage to a monster reduces its health by $ 1 $ .</p>
<p>Spells of type 1 can be cast any number of times, while a spell of type 2 can be cast at most once during the game.</p>
<p>What is the smallest number of times you need to cast spells of type 1 to kill all monsters?</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>Each test case consists of two lines. The first line contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of monsters.</p>
<p>The second line contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \le a_i \le n $ ) — monsters’ health points.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print a single integer — the smallest number of times you need to cast spells of type 1 to kill all monsters.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>操作2让每个怪物血量-1, 每次只要有一个怪物血量被减到0, 操作二就会重复进行, 直到没有怪物因为操作二死亡, 我们很直观的可以感受到操作二是很值当的一个操作</p>
<p>通过观察可以发现, 比如对于序列 1 2 3 4 5, 操作二会进行 5 + 1 次也就是6次, 那我们可以发现, 如果我们有一个以1开头且相邻元素的差值小于等于1的非递减序列, 我们操作二一共可以进行 (1 + 序列长度) 次, 因为操作二很值当, 我们希望操作二尽可能地进行得多一点, 那我们就希望可以有尽可能长的这样的序列, 为了方便叙述把这种序列称为<strong>好</strong>序列</p>
<p>构建这样的好序列是否会优于不构建这样的序列呢, 我们举个例子看看, 比如 1 2 3 5 6 7 这个序列, 如果不构建好序列, 需要进行几次操作1呢? 先进行一次操作二, 1 2 3没了然后5 6 7变成1 2 3, 需要6次操作1; 如果构建好序列, 5变成4, 6变成5, 7变成6, 只需要进行3次操作一, 明显构建好序列是优于不构建好序列的</p>
<p>那我们思路就是: 求出需要多少次操作1使得整个序列变成一个<strong>好</strong>序列</p>
<p>具体做法是, 先对序列排序, 然后从头开始遍历, cost记录所有的操作1的操作次数, last记录上一个数是什么, lastcost记录对上一个数进行了几次操作1, 注意cost和lastcost最小也就是0, 然后当前数 cur 需要的操作1的次数 &#x3D; cur - last + lastcost - 1(要让操作1尽可能少, 上一个数变成2, 这个数就可以变成3, 所以代价会少1).</p>
<p><strong>!</strong>: 考虑最坏情况每个数都是 $2\times10^5$ , 然后要变成从1到k, 粗略计算代价是 $2\times10^5\times2\times10^5$ , 是会爆int的, 要用long long存</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL; </span><br><span class="line">LL t, n, a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++) cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">		LL cost = <span class="number">0</span>, last = <span class="number">-1</span>, lastcost = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(!a[i]) <span class="keyword">continue</span>;</span><br><span class="line">			<span class="comment">//找到第一个非0的数</span></span><br><span class="line">			<span class="keyword">if</span>(last == <span class="number">-1</span> &amp;&amp; lastcost == <span class="number">-1</span>) last = a[i], lastcost = <span class="built_in">max</span>(<span class="number">0ll</span>, a[i] - <span class="number">1</span>), cost += </span><br><span class="line">                lastcost;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				LL t = a[i] - last + lastcost - <span class="number">1</span>; t = t &lt; <span class="number">0</span> ? <span class="number">0</span> : t; <span class="comment">//次数最小就是0</span></span><br><span class="line">				cost += t;</span><br><span class="line">				last = a[i], lastcost = t; </span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1788B/</url>
    <content><![CDATA[<h1 id="Sum-of-Two-Numbers"><a href="#Sum-of-Two-Numbers" class="headerlink" title="Sum of Two Numbers"></a>Sum of Two Numbers</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定一个 $n$，选取任意满足条件的两个非负整数 $x,y$ ,使得 $x,y$ 满足如下条件：</p>
<ul>
<li>$x+y&#x3D;n$</li>
<li>$x,y$ 的各位数字之和相差不超过 $1$</li>
</ul>
<p>多测，共有 $T$ 组数据。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The sum of digits of a non-negative integer $ a $ is the result of summing up its digits together when written in the decimal system. For example, the sum of digits of $ 123 $ is $ 6 $ and the sum of digits of $ 10 $ is $ 1 $ . In a formal way, the sum of digits of $ \displaystyle a&#x3D;\sum_{i&#x3D;0}^{\infty} a_i \cdot 10^i $ , where $ 0 \leq a_i \leq 9 $ , is defined as $ \displaystyle\sum_{i&#x3D;0}^{\infty}{a_i} $ .</p>
<p>Given an integer $ n $ , find two non-negative integers $ x $ and $ y $ which satisfy the following conditions.</p>
<ul>
<li>$ x+y&#x3D;n $ , and</li>
<li>the sum of digits of $ x $ and the sum of digits of $ y $ differ by at most $ 1 $ .</li>
</ul>
<p>It can be shown that such $ x $ and $ y $ always exist.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10,000 $ ).</p>
<p>Each test case consists of a single integer $ n $ ( $ 1 \leq n \leq 10^9 $ )</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print two integers $ x $ and $ y $ .</p>
<p>If there are multiple answers, print any.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">161</span></span><br><span class="line"><span class="number">67</span></span><br><span class="line"><span class="number">1206</span></span><br><span class="line"><span class="number">19</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">0</span></span><br><span class="line"><span class="symbol">67 </span><span class="number">94</span></span><br><span class="line"><span class="symbol">60 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1138 </span><span class="number">68</span></span><br><span class="line"><span class="symbol">14 </span><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>考虑 n 为偶数的情况, 直接拆成两个一样的就行了</p>
<p>考虑 n 为奇数的情况, 一开始我也是想着拆成两个一样的然后其中一个 +1 即可, 但是忽略了如果末位是9的话会有进位, 那就分为两种情况, n&#x2F;2(向下取整) 末尾不是9, 不会进位, 我们直接就找到答案</p>
<p>那如果末位是9呢, 如果连着末尾有一大串的9呢, 那我们此时发现 n&#x2F;2 + 1 会比 n&#x2F;2 的第一个不是9的位记为 k (从低位往高位数)多1, 又发现9可以拆成4和5, 刚好差值也是1, 我们可以让 n&#x2F;2 后边连着的9变成0, 就是减去这些数, 然后让5和4交替分配给 n&#x2F;2 + 1 和 n&#x2F;2(改变后的) 即可, 要记得此时 n&#x2F;2 + 1 的第 k 位可是比 n&#x2F;2 多1, 所以 n&#x2F;2 分到的5应该尽可能比 n&#x2F;2 + 1 分到的要多一个即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span>) cout &lt;&lt; n / <span class="number">2</span> &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; n / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t = (n - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span>(t % <span class="number">10</span> != <span class="number">9</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; t + <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> len = <span class="number">0</span>, tmp = t, q = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">while</span>(tmp)	<span class="comment">//取出后边那一串连续的9</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(tmp % <span class="number">10</span> == <span class="number">9</span>) q = q * <span class="number">10</span> + <span class="number">9</span>, len++;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">					tmp /= <span class="number">10</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">int</span> a = t - q, b = t + <span class="number">1</span>;</span><br><span class="line">				<span class="type">int</span> u = <span class="number">0</span>;	<span class="comment">//u是要分给 n/2 的, 要多给一个5给它</span></span><br><span class="line">				<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span>(i &lt;= (len + <span class="number">1</span>) / <span class="number">2</span>) u = u * <span class="number">10</span> + <span class="number">5</span>;	<span class="comment">//向上取整</span></span><br><span class="line">					<span class="keyword">else</span> u = u * <span class="number">10</span> + <span class="number">4</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				a += u, b += (q - u);</span><br><span class="line">				cout &lt;&lt; a &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">			&#125;	</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1789C/</url>
    <content><![CDATA[<h1 id="Serval-and-Toxel’s-Arrays"><a href="#Serval-and-Toxel’s-Arrays" class="headerlink" title="Serval and Toxel’s Arrays"></a>Serval and Toxel’s Arrays</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给你一个零时刻的长度为 $n$ 的数组 $a_i$。</p>
<p>时刻 $i\ (1 \le i \le m)$ 的数组是在时刻 $i-1$ 的基础上把位置 $p_i$ 的数改成 $v_i$ 得到的。</p>
<p>现在让你求出 $\sum_{i&#x3D;0}^m \sum_{j&#x3D;i+1}^m f(i,j)$，其中 $f(i,j)$ 的值为时刻 $i$ 和时刻 $j$ 的数组拼起来后一共有几种数字。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Toxel likes arrays. Before traveling to the Paldea region, Serval gave him an array $ a $ as a gift. This array has $ n $ pairwise distinct elements.</p>
<p>In order to get more arrays, Toxel performed $ m $ operations with the initial array. In the $ i $ -th operation, he modified the $ p_{i} $ -th element of the $ (i-1) $ -th array to $ v_{i} $ , resulting in the $ i $ -th array (the initial array $ a $ is numbered as $ 0 $ ). During modifications, Toxel guaranteed that the elements of each array are still pairwise distinct after each operation.</p>
<p>Finally, Toxel got $ m+1 $ arrays and denoted them as $ A_{0}&#x3D;a, A_{1},\ldots,A_{m} $ . For each pair $ (i,j) $ ( $ 0\le i&lt;j\le m $ ), Toxel defines its value as the number of distinct elements of the concatenation of $ A_{i} $ and $ A_{j} $ . Now Toxel wonders, what is the sum of the values of all pairs? Please help him to calculate the answer.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1\le t\le10^{4} $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers $ n $ and $ m $ ( $ 1\le n,m\le2\cdot10^{5} $ ) — the length of the array and the number of operations.</p>
<p>The second line of each test case contains $ n $ integers $ a_{1},a_{2},\dots,a_{n} $ ( $ 1\le a_{i}\le n+m $ ). It is guaranteed that all $ a_i $ are pairwise distinct.</p>
<p>Each of the next $ m $ lines of each test case contains two integers $ p_{i} $ and $ v_{i} $ ( $ 1\le p_{i}\le n $ , $ 1\le v_{i}\le n+m $ ) — the position of the modified element and its new value. It is guaranteed that the elements of each array are still pairwise distinct after each modification.</p>
<p>It is guaranteed that the sum of $ n $ and the sum of $ m $ over all test cases do not exceed $ 2\cdot10^{5} $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print a single integer — the sum of the values of all pairs of arrays.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span> <span class="number">9</span> <span class="number">12</span> <span class="number">16</span> <span class="number">20</span> <span class="number">2</span> <span class="number">10</span> <span class="number">19</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">17</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">18</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">11</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">17</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">13</span><br><span class="line">1</span><br><span class="line">705</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>定义 $(i,j)$ 是把第 $i$ 时刻的数组 $A_i$ 和第 $j$ 时刻的数组 $A_j$ 合起来, 问有几个不同的数, 即去重之后剩下几个数</p>
<p>暴力做法会TLE, 想到我之前写的那道题也是从每个数的贡献入手, 这道题也可以这么做,</p>
<p>因为保证了每个时刻的数组A内元素都是两两不同的, 我们可以统计数字x的出现次数记为 $cnt_x$, 也就是在 $cnt_x$ 个 $A$ 中出现了, 那么就剩下 $m+1-cnt_x$ 个 $A$ 中没有出现 $x$ 的, 记出现 $x$ 的 $A$ 为 $A_x$ , 没有出现 $x$的 $A$ 为 $A_y$</p>
<ul>
<li>当 $A_x$ 和 $A_y$ 合一起的时候, $x$ 对答案的贡献为1, 总共贡献为 $A_x个数\times A_y个数$ </li>
<li>当两个不同时刻的 $A_x$ 合在一起的时候, 因为去重之后还是会剩下一个 $x$ 所以 $x$ 对答案的贡献仍为1, 总共贡献为 $\Large\frac{A_x个数\times (A_x个数-1)}{2}$</li>
</ul>
<p>综上, $x$ 的总贡献就是上述两式相加</p>
<p>因为 $A$ 内元素各不相同, 所以以上两种情况中不会出现同一时刻的数组合在一起的情况, 大可以放心</p>
<p>那我们的思路就是: 统计每个 $x$ 的出现次数, 然后根据公式就可以计算出答案</p>
<p>提供一种统计每个 $x$ 出现次数的方法: $last_x$ 是 $x$ 上一次出现的时刻 $i$ , $last_x&#x3D;0$ 表示初时刻就出现了, $last_x&#x3D;-1$ 表示还没出现. 当某一时刻 $j$ 要让本来是 $x$ 的位置变成别的数的时候, 我们不难发现 $j-i$ 就是 $x$ 的出现次数了, 又因为是靠不同来更新的, 所以要记得扫尾</p>
<p><strong>!</strong>: 如果所有时刻所有数都不同, ans 可能会到 $n\times m$ 即 $4\times10^{10}$ 量级, 保险起见用long long存</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">4e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], cnt[N], last[N];		<span class="comment">// 数组现状, 数字出现次数, 某数字的出现位置</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;	<span class="comment">//n是数组长度 m是时刻</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) cnt[i] = <span class="number">0</span>, last[i] = <span class="number">-1</span>;	<span class="comment">// 多例要清空</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i], last[a[i]] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> p, y; cin &gt;&gt; p &gt;&gt; y;</span><br><span class="line">			<span class="keyword">if</span> (a[p] != y)</span><br><span class="line">			&#123;</span><br><span class="line">				cnt[a[p]] += i - last[a[p]], last[a[p]] = <span class="number">-1</span>;	<span class="comment">// 别忘记更新x的last出现位置</span></span><br><span class="line">				<span class="comment">// 更新数组a和last</span></span><br><span class="line">				a[p] = y, last[y] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 别忘记扫尾</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + m; i++) </span><br><span class="line">            <span class="keyword">if</span> (last[i] != <span class="number">-1</span>) cnt[i] += m - last[i] + <span class="number">1</span>;	<span class="comment">// 是m 别写成n了</span></span><br><span class="line"></span><br><span class="line">		LL ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n+m; i++)	<span class="comment">// 这里不能遍历1到9, 因为是根据n+m来清空的, 只能遍历到n+m</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans += cnt[i] * <span class="built_in">LL</span>(m + <span class="number">1</span> - cnt[i]);</span><br><span class="line">			ans += <span class="built_in">LL</span>(cnt[i] - <span class="number">1</span>) * cnt[i] / <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1789A/</url>
    <content><![CDATA[<h1 id="Serval-and-Mocha’s-Array"><a href="#Serval-and-Mocha’s-Array" class="headerlink" title="Serval and Mocha’s Array"></a>Serval and Mocha’s Array</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>对于一个正整数数组 $ a $ ，如果 $ a $ 中所有元素的最大公约数不超过其长度，那么这个数组就是<strong>好</strong>的。</p>
<p>对于一个至少有 $ 2 $ 个正整数的数组，如果其长度不小于 $ 2 $ 的所有前缀都是好的，那么这个数组就是<strong>完美</strong>的。</p>
<p>例如：</p>
<ul>
<li>$ [3,6] $ 不好，因为$ \gcd(3,6)&#x3D;3 $大于其长度 $ 2 $ 。</li>
<li>$ [1,2,4] $ 既好又完美，因为其长度不小于 $ 2 $ 的所有前缀，即 $ [1,2] $ 和 $ [1,2,4] $ ，都是好的。</li>
<li>$ [3,6,1] $ 好但不完美，因为$ [3,6] $ 不好。</li>
</ul>
<p>给定一个含有 $ n $ 个正整数的数组，请你判断数组 $ a $ 是否可以<strong>通过重新排列 $ a $ 中的元素</strong>而<strong>变得完美</strong>。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Mocha likes arrays, and Serval gave her an array consisting of positive integers as a gift.</p>
<p>Mocha thinks that for an array of positive integers $ a $ , it is good iff the <a href="https://en.wikipedia.org/wiki/Greatest_common_divisor">greatest common divisor</a> of all the elements in $ a $ is no more than its length. And for an array of at least $ 2 $ positive integers, it is beautiful iff all of its prefixes whose length is no less than $ 2 $ are good.</p>
<p>For example:</p>
<ul>
<li>$ [3,6] $ is not good, because $ \gcd(3,6)&#x3D;3 $ is greater than its length $ 2 $ .</li>
<li>$ [1,2,4] $ is both good and beautiful, because all of its prefixes whose length is no less than $ 2 $ , which are $ [1,2] $ and $ [1,2,4] $ , are both good.</li>
<li>$ [3,6,1] $ is good but not beautiful, because $ [3,6] $ is not good.</li>
</ul>
<p>Now Mocha gives you the gift array $ a $ of $ n $ positive integers, and she wants to know whether array $ a $ could become beautiful by reordering the elements in $ a $ . It is allowed to keep the array $ a $ unchanged.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1\leq t\leq 500 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2\leq n\leq 100 $ ) — the length of array $ a $ .</p>
<p>The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\leq a_1,a_2,\ldots,a_n\leq 10^6 $ ) — the elements of array $ a $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print Yes if it is possible to reorder the elements in $ a $ to make it beautiful, and print No if not.</p>
<p>You can output Yes and No in any case (for example, strings yEs, yes, Yes and YES will be recognized as a positive response).</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">35</span> <span class="number">21</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">35 </span><span class="number">10</span> <span class="number">35</span> <span class="number">14</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1261 </span><span class="number">227821</span> <span class="number">143</span> <span class="number">4171</span> <span class="number">1941</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">No</span></span><br><span class="line"><span class="keyword">Yes</span></span><br><span class="line"><span class="keyword">Yes</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们要明确, 数越多, 对于 $gcd$ 越严格, 换句话说就是数越多, $gcd$ 只可能越来越小, 如果 $gcd(a_1, a_2, a_3….a_n)&#x3D;k$, 那么 $k$ 只会小于等于 $gcd(ai, aj)$ , 反过来也就是说 <strong>对于一段序列 $p$ 如果 $p$ 的 $\large gcd &#x3D; k$, 就不存在 $\large gcd(p_i, p_j)&lt;k$</strong> , 因为gcd不可能变大只可能变小</p>
<p>定义一段序列为好当且仅当这段序列的 $gcd$ 小于等于序列长度, 无论如果都要解决长度为2的前缀, 所以我们需要两个数的 $gcd\le2$ , 又因为当序列变长时 $gcd$ 有不增加的性质, 所以如果有两个数的 $gcd&#x3D;2$ , 把他们放到开头, 就能保证序列 a 是完美的, 反之如果不存在这样两个数, 那么序列就不可能完美</p>
<p>本题虽然不难, 但是能帮助我更好的理解 <strong>最大公因数</strong> 的一些性质</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> f[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			cin &gt;&gt; f[i];</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">gcd</span>(f[i], f[j]) &lt;= <span class="number">2</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					flag = <span class="literal">true</span>; <span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (flag) cout &lt;&lt; <span class="string">&quot;yes\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1793B/</url>
    <content><![CDATA[<h1 id="Fedya-and-Array"><a href="#Fedya-and-Array" class="headerlink" title="Fedya and Array"></a>Fedya and Array</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有一个 $n$ 个元素的序列 $a$，元素首尾相连排成圆环，任意两个相邻元素间差的绝对值等于 $1$。定义一个局部最小值为<strong>同时</strong>小于左右两个相邻元素的元素值，一个局部最大值为<strong>同时</strong>大于左右两个相邻元素的元素值。</p>
<p><strong>注意，元素 $a_n$ 和 元素 $a_1$ 是相邻元素。</strong></p>
<p>给定序列 $a$ 中<strong>所有</strong>局部最大值的和以及序列 $a$ 中<strong>所有</strong>局部最小值的和，请还原出<strong>元素个数最少</strong>的数组 $a$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>For his birthday recently Fedya was given an array $ a $ of $ n $ integers arranged in a circle, For each pair of neighboring numbers ( $ a_1 $ and $ a_2 $ , $ a_2 $ and $ a_3 $ , $ \ldots $ , $ a_{n - 1} $ and $ a_n $ , $ a_n $ and $ a_1 $ ) the absolute difference between them is equal to $ 1 $ .</p>
<p>Let’s call a local maximum an element, which is greater than both of its neighboring elements. Also call a local minimum an element, which is less than both of its neighboring elements. Note, that elements $ a_1 $ and $ a_n $ are neighboring elements.</p>
<p>Unfortunately, Fedya lost an array, but he remembered in it the sum of local maximums $ x $ and the sum of local minimums $ y $ .</p>
<p>Given $ x $ and $ y $ , help Fedya find any matching array of minimum length.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). Description of the test cases follows.</p>
<p>Each line of each test case contain two integers $ x $ and $ y $ ( $ -10^{9} \le y &lt; x \le 10^{9} $ ) — the sum of local maximums and the sum of local minimums, respectively.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, in the first line print one integer $ n $ — the minimum length of matching arrays.</p>
<p>In the second line print $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ -10^{9} \leqslant a_i \leqslant 10^{9} $ ) — the array elements such that the the absolute difference between each pair of neighboring is equal to $ 1 $ .</p>
<p>If there are multiple solutions, print any of them.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^{5} $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span>-<span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span>-<span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span>-<span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span>-<span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">10</span><br><span class="line">0<span class="number"> 1 </span>2<span class="number"> 1 </span>0 -1<span class="number"> 0 </span>-1<span class="number"> 0 </span>1</span><br><span class="line">16</span><br><span class="line">-2 -1 -2 -1<span class="number"> 0 </span>1<span class="number"> 2 </span>3<span class="number"> 4 </span>5<span class="number"> 4 </span>3<span class="number"> 2 </span>1<span class="number"> 0 </span>-1 </span><br><span class="line">6</span><br><span class="line">1<span class="number"> 0 </span>-1<span class="number"> 0 </span>1 0</span><br><span class="line">16</span><br><span class="line">2<span class="number"> 3 </span>2<span class="number"> 1 </span>0 -1<span class="number"> 0 </span>-1<span class="number"> 0 </span>-1<span class="number"> 0 </span>1<span class="number"> 2 </span>1<span class="number"> 0 </span>1</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>是一道数学构造题</p>
<p>要求构造出一个环, 相邻元素差为1, 且所有比左右两个数都大的数的和为 $x$, 所有比左右两个数都小的数的和为 $y$</p>
<p>以 $x&#x3D;3$ , $y&#x3D;-2$ 为例: </p>
<ol>
<li><p>3是由一个局部最大值构成, -2是由一个局部最小值构成, 那么就是0到3, 3到-2, -2到2, 这样构造出来的数组的长度就是 $(x-y)\times2$ , 因为对于任意的 $x$ 和 $y$ 来说都可以这样分解, 所以对于任意的 $x$ 和 $y$ 来说都适用</p>
</li>
<li><p>3是由多个局部最大值组成, 那么就可以是0到2, 2到0, 0到1, 1到0, 0到-2, -2到-1, 此时数组的长度就是</p>
<p>$\sum_{i &#x3D; 1}^{i\le n} x_i\times2$, 对于 $y$ 同理, 不难看出第二种构造方法的长度与第一种是相同的</p>
</li>
</ol>
<p>这两种构造都是能使长度最短的, 我们采取比较好写的第一种</p>
<p><strong>!</strong>: 但是有可能 $x$ 和 $y$ 都大于0或者小于0, 所以我们不能从0开始, 要从 $x$ 或者 $y$ 开始, 记得保证首尾差值为1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> x, y; cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">		cout &lt;&lt; (x - y) * <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> i;</span><br><span class="line">		<span class="keyword">for</span> (i = x; i &gt; y; i--)</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (; i &lt; x; i++)</span><br><span class="line">			cout &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1793C/</url>
    <content><![CDATA[<h1 id="Dora-and-Search"><a href="#Dora-and-Search" class="headerlink" title="Dora and Search"></a>Dora and Search</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个长度为 $n$ 的排列 $a$ ，问是否存在正整数 $l,r$ 使得 $a_l,a_r$ 均不为 $a_{l…r}$ 中的最大值或最小值。</p>
<h3 id="输入输出格式"><a href="#输入输出格式" class="headerlink" title="输入输出格式"></a>输入输出格式</h3><p>第一行一个正整数 $t$ ，表示数据组数。接下来对于每组数据输入包括两行，第一行一个正整数 $n$ ，第二行 $n$ 个正整数代表排列 $a$ 。<br>对于每组数据，若存在符合要求的 $l,r$ ，输出任意一组。若不存在则输出 $-1$ 。</p>
<h3 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h3><p>$1\leqslant t \leqslant 10\ 000\ ,\ 1\leqslant \Sigma n \leqslant 200\ 000\ ,\ $ $a$ 是一个排列。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>As you know, the girl Dora is always looking for something. This time she was given a permutation, and she wants to find such a subsegment of it that none of the elements at its ends is either the minimum or the maximum of the entire subsegment. More formally, you are asked to find the numbers $ l $ and $ r $ $ (1 \leq l \leq r \leq n) $ such that $ a_l \neq \min(a_l, a_{l + 1}, \ldots, a_r) $ , $ a_l \neq \max(a_l, a_{l + 1}, \ldots, a_r) $ and $ a_r \neq \min(a_l, a_{l + 1}, \ldots, a_r) $ , $ a_r \neq \max(a_l, a_{l + 1}, \ldots, a_r) $ .</p>
<p>A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in any order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ occurs twice in the array) and $ [1,3,4] $ is also not a permutation ( $ n&#x3D;3 $ , but $ 4 $ is present in the array).</p>
<p>Help Dora find such a subsegment, or tell her that such a subsegment does not exist.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. Description of the test cases follows.</p>
<p>For each test case, the first line contains one integer $ n $ ( $ 1 \leq n \leq 2 \cdot 10^5 $ ) — the length of permutation.</p>
<p>The second line contains $ n $ distinct integers $ a_1, a_2, \ldots, a_n $ ( $ 1 \leq a_i \leq n $ ) — the elements of permutation.</p>
<p>It is guarented that the sum of $ n $ over all test cases doesn’t exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output $ -1 $ if the desired subsegment does not exist.</p>
<p>Otherwise, output two indexes $ l, r $ such that $ [a_{l}, a_{l + 1}, \ldots, a_{r}] $ satisfies all conditions.</p>
<p>If there are several solutions, then output any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-1</span></span><br><span class="line">1 4</span><br><span class="line">2 6</span><br><span class="line"><span class="deletion">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给了一个只含有元素1到n且两两不同的数组, 要求我们找出一段子区间, 子区间端点不是这段子区间的最值</p>
<p>首先我们要想明白, 随着区间的缩短, 区间最大值单调不升, 区间最小值单调不降, 那么对于一段区间而言如果它不合法, 那我们就试着排掉不合法的端点, 缩小区间, 直到区间合法或者答案不存在</p>
<p>具体的做法是: 我们先尝试全选, 因为序列一定含有1到n, 所以很明显全选的最大值是n, 最小值是n, 如果端点不等于最值, 那么我们直接选, 如果其中一个端点a等于最值, 例如等于n, 那么我们操作a(加1或者减1)缩小区间, 同时因为等于n的点被排除在外了, 剩下的点的最大值肯定就是n-1, 我们再进行对端点进行判断, 重复直到找到答案或者明确答案不存在</p>
<p><strong>一些心得</strong>: 我就说只含有1到n是个解题很关键的性质, 我们可以确定整段序列上的最大值和最小值是n和1, 并且如果我们删除了n, 那我们就知道最大值就会变成n-1</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> l = <span class="number">1</span>, r = n, minn = <span class="number">1</span>, maxn = n;</span><br><span class="line">		<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//等于极值, 区间缩小, 且极值被排除在外</span></span><br><span class="line">			<span class="keyword">if</span> (a[l] == minn) &#123; l++, minn++; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">if</span> (a[l] == maxn) &#123; l++, maxn--; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">if</span> (a[r] == minn) &#123; r--, minn++; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">if</span> (a[r] == maxn) &#123; r--, maxn--; <span class="keyword">continue</span>; &#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (l &lt; r) cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1794A/</url>
    <content><![CDATA[<h1 id="Prefix-and-Suffix-Array"><a href="#Prefix-and-Suffix-Array" class="headerlink" title="Prefix and Suffix Array"></a>Prefix and Suffix Array</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>马科斯非常喜爱字符串，他有一个最爱的字符串 $s$，里面只由小写英文字母组成。</p>
<p>对于这个字符串 $s$，马科斯在一张纸上胡乱写下了 $s$ 的所有<strong>非空真前缀子串</strong>和<strong>非空真后缀子串</strong>（因为是胡乱写下的，所以这并没有什么顺序）。你看到了这张纸，看到了写在上面的所有字符串，现在你很好奇：马科斯最爱的字符串 $s$ 是不是一个<strong>回文串</strong>。</p>
<p>你的任务是：利用字符串 $s$ 的所有<strong>非空真前缀子串</strong>和<strong>非空真后缀子串</strong>，判断 $s$ 是否是一个<strong>回文串</strong>。</p>
<p>一个字符串 $a$ 是另一个字符串 $b$ 的<strong>非空真前缀子串</strong>，当且仅当从 $b$ 的末尾删去一部分后，剩下的一部分就是 $a$。</p>
<p>一个字符串 $a$ 是另一个字符串 $b$ 的<strong>非空真后缀子串</strong>，当且仅当从 $b$ 的开头删去一部分后，剩下的一部分就是 $a$。</p>
<p>一个<strong>回文串</strong>从前往后读和从后往前读是一模一样的。例如，字符串 $\texttt{gg}$，$\texttt{ioi}$，$\texttt{abba}$，$\texttt{icpci}$ 是回文串，而字符串 $\texttt{codeforces}$，$\texttt{abcd}$，$\texttt{alt}$ 不是回文串。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Marcos loves strings a lot, so he has a favorite string $ s $ consisting of lowercase English letters. For this string, he wrote down all its non-empty prefixes and suffixes (except for $ s $ ) on a piece of paper in arbitrary order. You see all these strings and wonder if Marcos’ favorite string is a palindrome or not. So, your task is to decide whether $ s $ is a palindrome by just looking at the piece of paper.</p>
<p>A string $ a $ is a prefix of a string $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero or all) characters from the end.</p>
<p>A string $ a $ is a suffix of a string $ b $ if $ a $ can be obtained from $ b $ by deletion of several (possibly, zero or all) characters from the beginning.</p>
<p>A palindrome is a string that reads the same backward as forward, for example, strings “gg”, “ioi”, “abba”, “icpci” are palindromes, but strings “codeforces”, “abcd”, “alt” are not.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 120 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2\le n \le 20 $ ) — the length of the string $ s $ .</p>
<p>The second line of each test case contains $ 2n-2 $ strings $ a_1, a_2, \cdots, a_{2n-2} $ — all non-empty prefixes and suffixes of $ s $ , not including itself, in arbitrary order.</p>
<p>It is guaranteed that these strings are all the non-empty prefixes and suffixes of some string consisting of lowercase English letters.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output “YES” if $ s $ is a palindrome, and “NO” otherwise.</p>
<p>You can output the answer in any case (upper or lower). For example, the strings “yEs”, “yes”, “Yes”, and “YES” will be recognized as positive responses.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">bcd <span class="keyword">cd</span> <span class="keyword">a</span> d <span class="keyword">abc</span> <span class="keyword">ab</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">i io i oi</span><br><span class="line"><span class="number">2</span></span><br><span class="line">g g</span><br><span class="line"><span class="number">3</span></span><br><span class="line">t <span class="keyword">al</span> <span class="keyword">lt</span> <span class="keyword">a</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line">bba <span class="keyword">a</span> <span class="keyword">ab</span> <span class="keyword">a</span> abb <span class="keyword">ba</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>回文串的定义就是一个字符串从前往后读跟从后往前读是一样的, 那么比如s是一个回文串, 我把s的尾部字符删了得到s1, 把s的头部字符删了得到s2, 从前往后跟从后往前读是一样的, 那么不就说明s1 &#x3D; s2.reverse() 吗</p>
<p>那我们我就得出s是回文串当且仅当s1 &#x3D; s2.reverse()</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string s[<span class="number">110</span>];</span><br><span class="line"><span class="type">int</span> len[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a, string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> p = a.<span class="built_in">size</span>(), q = b.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> p &gt; q;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n - <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; s[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(s, s + <span class="number">2</span> * n - <span class="number">2</span>, cmp);</span><br><span class="line"></span><br><span class="line">		string s1 = s[<span class="number">0</span>], s2 = s[<span class="number">1</span>];</span><br><span class="line">		<span class="type">int</span> i = <span class="number">0</span>, j = s2.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">while</span> (i &lt; j)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">swap</span>(s2[i], s2[j]);</span><br><span class="line">			i++, j--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (s1 == s2) cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1794B/</url>
    <content><![CDATA[<h1 id="Not-Dividing"><a href="#Not-Dividing" class="headerlink" title="Not Dividing"></a>Not Dividing</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>$ T $ 组数据，每次给定 $ n $ 个正整数 $ a_i $。</p>
<p>任选一个 $ a_i $，令 $ a_i \gets a_i + 1 $，被称为一次操作。</p>
<p>要求进行至多 $2n$ 次操作后，对 $ i &#x3D; 1, 2, \cdots n - 1 $，$ a_{i + 1} \mod a_i \neq 0 $。</p>
<p>输出操作结束后的 $a_i$，符合以上要求。</p>
<p>题目保证 $1 \le T \le {10}^4$，$1 \le n \le {10}^4$，$1 \le \Sigma \space n \le 5 \cdot {10}^4 $。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given an array of $ n $ positive integers $ a_1, a_2, \ldots, a_n $ . In one operation, you can choose any number of the array and add $ 1 $ to it.</p>
<p>Make at most $ 2n $ operations so that the array satisfies the following property: $ a_{i+1} $ is not divisible by $ a_i $ , for each $ i &#x3D; 1, 2, \ldots, n-1 $ .</p>
<p>You do not need to minimize the number of operations.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains an integer $ n $ ( $ 1\le n\le 10^4 $ ) — the length of the given array.</p>
<p>The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\le a_i\leq 10^9 $ ) — the given array.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5\cdot 10^4 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print the answer on a separate line.</p>
<p>In the only line, print $ n $ integers — the resulting array $ a $ after applying at most $ 2n $ operations.</p>
<p>We can show that an answer always exists under the given constraints. If there are multiple answers, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">3</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">4 </span><span class="number">5</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$a_{i+1}$ 不能被 $a_i$ 整除, 有什么性质呢, 我们很自然的就可以想到$a_{i+1}$ 和 $a_i$ 的最小公倍数就应该是他们两个的乘积, 那我们遍历数组 $a$, 如果 $lcm(a_i,a_{i+1})\neq a_i\times a_{i+1}$ , 那么我们就让 $a_i$ 加一直到满足 $a_{i+1}$ 和 $a_i$ 的最小公倍数是他们两个的乘积 </p>
<p>存在特殊情况是 $a_i&#x3D;1$ 的时候, 也满足和 $a_{i+1}$ 的最小公倍数是他俩的乘积, 但是任何数都可以被1整除, 解决方法也很简单, 在读入的时候如果遇上1就加上1让它变成2就可以了</p>
<p><strong>!</strong>: $a_i$ 是 $10^9$ 级, 求公倍数会爆int, 要开long long存</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line">ULL a[N];</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">gcd</span><span class="params">(ULL a, ULL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ULL <span class="title">lcm</span><span class="params">(ULL a, ULL b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">			<span class="keyword">if</span> (a[i] == <span class="number">1</span>) a[i]++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ULL mlcm = <span class="built_in">lcm</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">if</span> (mlcm != a[i] * a[i - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; <span class="built_in">lcm</span>(a[i], a[i - <span class="number">1</span>]) != a[i] * a[i - <span class="number">1</span>]; i++)</span><br><span class="line">					a[i]++;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cout &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1794C/</url>
    <content><![CDATA[<h1 id="Scoring-Subsequences"><a href="#Scoring-Subsequences" class="headerlink" title="Scoring Subsequences"></a>Scoring Subsequences</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>定义序列 $[s_1,s_2,\cdots,s_d]$ 的<em>得分</em>为<br>$$\frac{s_1 \cdot s_2 \cdot \dots \cdot s_d}{d!}$$</p>
<p>特别地，空序列的得分为 $1$。</p>
<p>定义序列 $[s_1,s_2,\cdots,s_d]$ 的<em>花费</em>为原序列中取得最大得分的所有子序列，其中最长的一个子序列的长度。</p>
<p>给定单调不减序列 $[a_1,a_2,\dots,a_n]$，对每个 $k&#x3D;1,2,\cdots n$，求 $[a_1,a_2,\cdots ,a_k]$ 的花费。</p>
<p>规定某个序列的子序列是从最初序列通过去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The score of a sequence $ [s_1, s_2, \ldots, s_d] $ is defined as $ \displaystyle \frac{s_1\cdot s_2\cdot \ldots \cdot s_d}{d!} $ , where $ d!&#x3D;1\cdot 2\cdot \ldots \cdot d $ . In particular, the score of an empty sequence is $ 1 $ .</p>
<p>For a sequence $ [s_1, s_2, \ldots, s_d] $ , let $ m $ be the maximum score among all its subsequences. Its cost is defined as the maximum length of a subsequence with a score of $ m $ .</p>
<p>You are given a non-decreasing sequence $ [a_1, a_2, \ldots, a_n] $ of integers of length $ n $ . In other words, the condition $ a_1 \leq a_2 \leq \ldots \leq a_n $ is satisfied. For each $ k&#x3D;1, 2, \ldots , n $ , find the cost of the sequence $ [a_1, a_2, \ldots , a_k] $ .</p>
<p>A sequence $ x $ is a subsequence of a sequence $ y $ if $ x $ can be obtained from $ y $ by deletion of several (possibly, zero or all) elements.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains an integer $ n $ ( $ 1\le n\le 10^5 $ ) — the length of the given sequence.</p>
<p>The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\le a_i\leq n $ ) — the given sequence. It is guaranteed that its elements are in non-decreasing order.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5\cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output $ n $ integers — the costs of sequences $ [a_1, a_2, \ldots , a_k] $ in ascending order of $ k $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> </span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>得分 &#x3D; $\Large{\frac{s_1\cdot s_2 \cdot…\cdot s_k}{k!}}$ ,  对于序列 a , 我们进行一下变形得到 a’ : $\Large \frac{a_1}{k}$ , $\Large \frac{a_2}{k-1}$ , … $\Large \frac{a_n}{1}$ </p>
<p>我们发现 $\Large \frac{a_1}{k}\cdot\frac{a_2}{k-1}\cdot\frac{a_3}{k-2}\cdot…\cdot\frac{a_k}{1}&#x3D;     \frac{a_1\cdot a_2\cdot…\cdot a_n}{k!}$ , 且变形后的序列 a’ 仍是单调非递减的</p>
<p>为了让长度最大, 我们要包含所有 a’ 中 $\ge 1$ 的所有项</p>
<p>因为 a’ 具有单调性, 对于每一个k, 我们可以用二分找到第一个 $\ge 1$ 的项, 然后就能得到最长的长度</p>
<p>其实也包含了贪心的思想</p>
<p><strong>!</strong>: 为了避免精度的误差, 条件 $\large\frac{a_i}{k-i+1}\ge1$ 应写为 $a_i\ge k-i+1$ </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l = <span class="number">1</span>, r = i;</span><br><span class="line">            <span class="comment">//二分的判断条件由希望找到的区间边界性质决定</span></span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">if</span> (a[mid] &gt;= i - mid + <span class="number">1</span>) r = mid;</span><br><span class="line">				<span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; i - l + <span class="number">1</span> &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1798C/</url>
    <content><![CDATA[<h1 id="Candy-Store"><a href="#Candy-Store" class="headerlink" title="Candy Store"></a>Candy Store</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有 $n$ 种糖，第 $i$ 种糖有 $a_i$ 块，每块 $b_i$ 元。对每种糖，你要选择一个 $d_i | a_i$，然后每 $d_i$ 块糖装进一个袋子。</p>
<p>现在把糖摆上货架，第 $i$ 类糖的价签上的价格 $c_i$ 是一袋子 $i$ 类糖的价值，即 $c_i &#x3D; d_i \times b_i$。</p>
<p>对于货架上一个区间 $[l, r]$，如果他们的价签相同，即 $c_l &#x3D; c_{l + 1} &#x3D; \dots &#x3D; c_r$，则他们可以共用一个价签。</p>
<p>请问最少需要多少价签？</p>
<p>多组数据，保证 $n$ 之和不超过 $2 \times 10^5$，$1 \leq a_i \leq 10^9$，$1 \leq b_i \leq 10^4$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The store sells $ n $ types of candies with numbers from $ 1 $ to $ n $ . One candy of type $ i $ costs $ b_i $ coins. In total, there are $ a_i $ candies of type $ i $ in the store.</p>
<p>You need to pack all available candies in packs, each pack should contain only one type of candies. Formally, for each type of candy $ i $ you need to choose the integer $ d_i $ , denoting the number of type $ i $ candies in one pack, so that $ a_i $ is divided without remainder by $ d_i $ .</p>
<p>Then the cost of one pack of candies of type $ i $ will be equal to $ b_i \cdot d_i $ . Let’s denote this cost by $ c_i $ , that is, $ c_i &#x3D; b_i \cdot d_i $ .</p>
<p>After packaging, packs will be placed on the shelf. Consider the cost of the packs placed on the shelf, in order $ c_1, c_2, \ldots, c_n $ . Price tags will be used to describe costs of the packs. One price tag can describe the cost of all packs from $ l $ to $ r $ inclusive if $ c_l &#x3D; c_{l+1} &#x3D; \ldots &#x3D; c_r $ . Each of the packs from $ 1 $ to $ n $ must be described by at least one price tag. For example, if $ c_1, \ldots, c_n &#x3D; [4, 4, 2, 4, 4] $ , to describe all the packs, a $ 3 $ price tags will be enough, the first price tag describes the packs $ 1, 2 $ , the second: $ 3 $ , the third: $ 4, 5 $ .</p>
<p>You are given the integers $ a_1, b_1, a_2, b_2, \ldots, a_n, b_n $ . Your task is to choose integers $ d_i $ so that $ a_i $ is divisible by $ d_i $ for all $ i $ , and the required number of price tags to describe the values of $ c_1, c_2, \ldots, c_n $ is the minimum possible.</p>
<p>For a better understanding of the statement, look at the illustration of the first test case of the first test:</p>
<p>Let’s repeat the meaning of the notation used in the problem:</p>
<p> $ a_i $ — the number of candies of type $ i $ available in the store.</p>
<p> $ b_i $ — the cost of one candy of type $ i $ .</p>
<p> $ d_i $ — the number of candies of type $ i $ in one pack.</p>
<p> $ c_i $ — the cost of one pack of candies of type $ i $ is expressed by the formula $ c_i &#x3D; b_i \cdot d_i $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100,000 $ ). Description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 200,000 $ ) — the number of types of candies.</p>
<p>Each of the next $ n $ lines of each test case contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i \le 10^9 $ , $ 1 \le b_i \le 10,000 $ ) — the number of candies and the cost of one candy of type $ i $ , respectively.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 200,000 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the minimum number of price tags required to describe the costs of all packs of candies in the store.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">20 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">14 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">20 </span><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">444 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2002 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">2020 </span><span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">2</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">12</span></span><br><span class="line"><span class="symbol">12 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">12</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1000000000 </span><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">1</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, you can choose $ d_1 &#x3D; 4 $ , $ d_2 &#x3D; 6 $ , $ d_3 &#x3D; 7 $ , $ d_4 &#x3D; 5 $ . Then the cost of packs will be equal to $ [12, 12, 35, 35] $ . $ 2 $ price tags are enough to describe them, the first price tag for $ c_1, c_2 $ and the second price tag for $ c_3, c_4 $ . It can be shown that with any correct choice of $ d_i $ , at least $ 2 $ of the price tag will be needed to describe all the packs. Also note that this example is illustrated by a picture in the statement.</p>
<p>In the second test case, with $ d_1 &#x3D; 4 $ , $ d_2 &#x3D; 2 $ , $ d_3 &#x3D; 10 $ , the costs of all packs will be equal to $ 20 $ . Thus, $ 1 $ price tag is enough to describe all the packs. Note that $ a_i $ is divisible by $ d_i $ for all $ i $ , which is necessary condition.</p>
<p>In the third test case, it is not difficult to understand that one price tag can be used to describe $ 2 $ nd, $ 3 $ rd and $ 4 $ th packs. And additionally a price tag for pack $ 1 $ and pack $ 5 $ . Total: $ 3 $ price tags.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>引入</strong>: $a|b$ 表示 $b$ 可以被 $a$ 整除</p>
<p>假设区间 $[l,r]$ 可以共用一个价签, 那么就有 $c_i&#x3D;b_l\times d_l+b_{l+1}\times d_{l+1}+…$ , 也就意味着在 $[l,r]$ 上 $b_i|c$ , 那么$c$ 肯定是 $b_l$ 到 $b_r$ 上所有 $b$ 的最小公倍数lcm的倍数, 也就有 $lcm(b_l,b_{l+1},…b_r)|c$ </p>
<p>再看 $d_i$ , 明显有 $b_i|a_i$ , 而 $d_i&#x3D;\frac{c}{b_i}$ , 就有 $\frac{c}{b_i}|a_i$ , 就有 $c|a_ib_i$ , $c$ 能被 $l$ 到 $r$ 上所有的 $ab$ 整除, 那么他肯定也能被所有 $ab$ 的最大gcd整除, 即$c|gcd(a_lb_l,a_{l+1}b{l+1},…)$ , $c$ 不会比这个gcd大, 因为如果比这个gcd大了那么gcd就会是 $c$</p>
<p>$c$ 能整除lcm, gcd能整除 $c$ , 那么如果gcd能整除lcm, 就能确定有一个合法的 $c$</p>
<p>而区间的选法运用贪心的思想, 仅可能的取多糖果, <strong>为什么这样子是正确的呢?</strong> 可以用简单的说明去帮助理解, 我们区间内糖果越多, 对于gcd和lcm的要求就越严格, 越严格就越难合法, 所以不尽可能的多取而留给下一区间, 不会让下一区间的长度变长</p>
<p><strong>!</strong>: a开到了 $10^9$ , 过程中的乘法会爆int, 要开 long long</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">ll a[N], b[N];</span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">lcm</span><span class="params">(ll a, ll b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> (a * b) / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; a[i] &gt;&gt; b[i];</span><br><span class="line">		</span><br><span class="line">		ll A = a[<span class="number">0</span>] * b[<span class="number">0</span>], B = b[<span class="number">0</span>];</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			A = <span class="built_in">gcd</span>(A, a[i] * b[i]), B = <span class="built_in">lcm</span>(B, b[i]);</span><br><span class="line">			<span class="keyword">if</span> (A % B)</span><br><span class="line">			&#123;</span><br><span class="line">				ans++;</span><br><span class="line">				A = a[i] * b[i], B = b[i];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1798D/</url>
    <content><![CDATA[<h1 id="Shocking-Arrangement"><a href="#Shocking-Arrangement" class="headerlink" title="Shocking Arrangement"></a>Shocking Arrangement</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给出一个长度为 $n$ 的数列 $a$，满足 $\sum_{i &#x3D; 1}^n a_i &#x3D; 0$。</p>
<p>你需要重排这个数列，使得重排后满足</p>
<p>$$\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n)$$</p>
<p>多组数据，$n$ 之和不超过 $3 \times 10^5$，$|a_i| \leq 10^9$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given an array $ a_1, a_2, \ldots, a_n $ consisting of integers such that $ a_1 + a_2 + \ldots + a_n &#x3D; 0 $ .</p>
<p>You have to rearrange the elements of the array $ a $ so that the following condition is satisfied:</p>
<p>$$\max\limits_{1 \le l \le r \le n} \lvert a_l + a_{l+1} + \ldots + a_r \rvert &lt; \max(a_1, a_2, \ldots, a_n) - \min(a_1, a_2, \ldots, a_n)$$ </p>
<p>where  $ |x| $  denotes the absolute value of  $ x $ .More formally, determine if there exists a permutation  $ p_1, p_2, \ldots, p_n $  that for the array  $ a_{p_1}, a_{p_2}, \ldots, a_{p_n} $ , the condition above is satisfied, and find the corresponding array.Recall that the array  $ p_1, p_2, \ldots, p_n $  is called a permutation if for each integer  $ x $  from  $ 1 $  to  $ n $  there is exactly one  $ i $  from  $ 1 $  to  $ n $  such that  $ p_i &#x3D; x$.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 50,000 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 300,000 $ ) — the length of the array $ a $ .</p>
<p>The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ -10^9 \le a_i \le 10^9 $ ) — elements of the array $ a $ . It is guaranteed that the sum of the array $ a $ is zero, in other words: $ a_1 + a_2 + \ldots + a_n &#x3D; 0 $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 300,000 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, if it is impossible to rearrange the elements of the array $ a $ in the required way, print “No” in a single line.</p>
<p>If possible, print “Yes” in the first line, and then in a separate line $ n $ numbers — elements $ a_1, a_2, \ldots, a_n $ rearranged in a valid order ( $ a_{p_1}, a_{p_2}, \ldots, a_{p_n} $ ).</p>
<p>If there are several possible answers, you can output any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">4</span><br><span class="line">3 4 <span class="string">-2</span> <span class="string">-5</span></span><br><span class="line">5</span><br><span class="line">2 2 2 <span class="string">-3</span> <span class="string">-3</span></span><br><span class="line">8</span><br><span class="line"><span class="string">-3</span> <span class="string">-3</span> 1 1 1 1 1 1</span><br><span class="line">3</span><br><span class="line">0 1 <span class="string">-1</span></span><br><span class="line">7</span><br><span class="line"><span class="string">-3</span> 4 3 4 <span class="string">-4</span> <span class="string">-4</span> 0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">7</span><br><span class="line"><span class="string">-18</span> 13 <span class="string">-18</span> <span class="string">-17</span> 12 15 13</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line">Yes</span><br><span class="line"><span class="string">-5</span> <span class="string">-2</span> 3 4</span><br><span class="line">Yes</span><br><span class="line"><span class="string">-3</span> 2 <span class="string">-3</span> 2 2</span><br><span class="line">Yes</span><br><span class="line">1 1 1 <span class="string">-3</span> 1 1 1 <span class="string">-3</span></span><br><span class="line">Yes</span><br><span class="line"><span class="string">-1</span> 0 1</span><br><span class="line">Yes</span><br><span class="line">4 <span class="string">-4</span> 4 <span class="string">-4</span> 0 3 <span class="string">-3</span></span><br><span class="line">No</span><br><span class="line">Yes</span><br><span class="line">13 12 <span class="string">-18</span> 15 <span class="string">-18</span> 13 <span class="string">-17</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果 $a$ 全为0, 显然无解</p>
<p>否则考虑从左到右构造新序列, 维护一个前缀和s, 要让任意区间上和的绝对值的最大值能够最小, 第一个想法肯定是尽可能一正一负的放元素, 但是这个想法不够准确, 我们并不能肯定正数和负数的数量就一定相等, 但是我们知道, $a1+a2+a3+a4+…+an&#x3D;0$ , 也就是说无论如何所有的数的和是0, 那么正确思路应该是:</p>
<ul>
<li>当 $s\ge0$ 的时候, 选一个非正数放过来, 更新前缀和</li>
<li>当 $s &lt; 0$ 的时候, 选一个正数放过来, 更新前缀和</li>
</ul>
<p>因为所有元素和为0, 那么以上两种情况肯定都能找到要放过来的数, 不然最后s怎么变成0呢</p>
<p>这样的构造能使得 $mina&lt;s&lt;maxa$ , 为什么呢? 当 $s\ge 0$ 的时候, 能够找来的最小的非正数也就是 $mina$ , 又因为 $s\ge 0$ , 所以 $s’&#x3D;s+mina&gt; mina$ ; 同理可以证明 $s&lt;maxa$</p>
<p>综上, 只有a全为0的时候答案不存在, 其他情况都能构造出答案</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll s; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; v1, v2;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">			flag |= a;	<span class="comment">//如果全是0 输出no</span></span><br><span class="line">			<span class="keyword">if</span> (a &lt;= <span class="number">0</span>)</span><br><span class="line">				v1.<span class="built_in">push_back</span>(a);	<span class="comment">//v1存小于等于0的</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				v2.<span class="built_in">push_back</span>(a);	<span class="comment">//v2存大于0的</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;NO\n&quot;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		s = v1.<span class="built_in">back</span>(), v1.<span class="built_in">pop_back</span>();</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s &gt;= <span class="number">0</span>)		<span class="comment">//找个负数来抵消</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> t = v1.<span class="built_in">back</span>();</span><br><span class="line">				v1.<span class="built_in">pop_back</span>();</span><br><span class="line">				s += t;</span><br><span class="line">				cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//找个正数来抵消s</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> t = v2.<span class="built_in">back</span>();</span><br><span class="line">				v2.<span class="built_in">pop_back</span>();</span><br><span class="line">				s += t;</span><br><span class="line">				cout &lt;&lt; t &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1805A/</url>
    <content><![CDATA[<h1 id="We-Need-the-Zero"><a href="#We-Need-the-Zero" class="headerlink" title="We Need the Zero"></a>We Need the Zero</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给出一个由非负整数组成的序列 $a$，请你选择一个 $x$，使得 $ (a_1 \oplus x) \oplus (a_2 \oplus x) \oplus \dots \oplus (a_n \oplus x) &#x3D; 0$。请求出 $x$，或者输出 $-1$ 表示不可能。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>There is an array $ a $ consisting of non-negative integers. You can choose an integer $ x $ and denote $ b_i&#x3D;a_i \oplus x $ for all $ 1 \le i \le n $ , where $ \oplus $ denotes the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR operation</a>. Is it possible to choose such a number $ x $ that the value of the expression $ b_1 \oplus b_2 \oplus \ldots \oplus b_n $ equals $ 0 $ ?</p>
<p>It can be shown that if a valid number $ x $ exists, then there also exists $ x $ such that ( $ 0 \le x &lt; 2^8 $ ).</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). The description of the test cases follows.</p>
<p>The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 10^3 $ ) — the length of the array $ a $ .</p>
<p>The second line of the test case contains $ n $ integers — array $ a $ ( $ 0 \le a_i &lt; 2^8 $ ).</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^3 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each set test case, print the integer $ x $ ( $ 0 \le x &lt; 2^8 $ ) if it exists, or $ -1 $ otherwise.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line"><span class="deletion">-1</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, after applying the operation with the number $ 6 $ the array $ b $ becomes $ [7, 4, 3] $ , $ 7 \oplus 4 \oplus 3 &#x3D; 0 $ .</p>
<p>There are other answers in the third test case, such as the number $ 0 $ .# We Need the Zero</p>
<h2 id="题面翻译-1"><a href="#题面翻译-1" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给出一个由非负整数组成的序列 $a$，请你选择一个 $x$，使得 $ (a_1 \oplus x) \oplus (a_2 \oplus x) \oplus \dots \oplus (a_n \oplus x) &#x3D; 0$。请求出 $x$，或者输出 $-1$ 表示不可能。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>There is an array $ a $ consisting of non-negative integers. You can choose an integer $ x $ and denote $ b_i&#x3D;a_i \oplus x $ for all $ 1 \le i \le n $ , where $ \oplus $ denotes the <a href="https://en.wikipedia.org/wiki/Bitwise_operation#XOR">bitwise XOR operation</a>. Is it possible to choose such a number $ x $ that the value of the expression $ b_1 \oplus b_2 \oplus \ldots \oplus b_n $ equals $ 0 $ ?</p>
<p>It can be shown that if a valid number $ x $ exists, then there also exists $ x $ such that ( $ 0 \le x &lt; 2^8 $ ).</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). The description of the test cases follows.</p>
<p>The first line of the test case contains one integer $ n $ ( $ 1 \le n \le 10^3 $ ) — the length of the array $ a $ .</p>
<p>The second line of the test case contains $ n $ integers — array $ a $ ( $ 0 \le a_i &lt; 2^8 $ ).</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^3 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each set test case, print the integer $ x $ ( $ 0 \le x &lt; 2^8 $ ) if it exists, or $ -1 $ otherwise.</p>
<h2 id="样例-1-1"><a href="#样例-1-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1-1"><a href="#样例输入-1-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1-1"><a href="#样例输出-1-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line"><span class="deletion">-1</span></span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示-1"><a href="#提示-1" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, after applying the operation with the number $ 6 $ the array $ b $ becomes $ [7, 4, 3] $ , $ 7 \oplus 4 \oplus 3 &#x3D; 0 $ .</p>
<p>There are other answers in the third test case, such as the number $ 0 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li><p>如果a的长度为偶数, 有 <code>(a1 ^ x) ^ (a2 ^ x) ^ ... ^ (an ^ x) = a1 ^ a2 ^ ... ^ an</code></p>
</li>
<li><p>如果a的长度为奇数, 有 <code>(a1 ^ x) ^ (a2 ^ x) ^ ... ^ (an ^ x) = a1 ^ a2 ^ ... ^ an ^ x</code></p>
</li>
</ul>
<p>我们计算 <code>xor = a1 ^ a2 ^ ... ^ an</code> , 如果a长度为偶数, xor &#x3D; 0 的时候, x可以是任何数, xor 不为0时, 没有答案, 如果a长度为奇数, x 就等于 xor</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> a[<span class="number">10000</span>];</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">			x ^= a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!x)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">0</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1805C/</url>
    <content><![CDATA[<h1 id="Place-for-a-Selfie"><a href="#Place-for-a-Selfie" class="headerlink" title="Place for a Selfie"></a>Place for a Selfie</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定 $n$ 个正比例函数 $y&#x3D;kx$，再给出 $m$ 个下凸二次函数 $y&#x3D;ax^2+bx+c(a&gt;0)$，对于每个二次函数，从给定中找出一个一次函数，使得两函数图像没有交点。</p>
<p>$\sum n,\sum m\le 10^5$，$a,|b|,|c|,|k|\le 10^8$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The universe is a coordinate plane. There are $ n $ space highways, each of which is a straight line $ y&#x3D;kx $ passing through the origin $ (0, 0) $ . Also, there are $ m $ asteroid belts on the plane, which we represent as open upwards parabolas, i. e. graphs of functions $ y&#x3D;ax^2+bx+c $ , where $ a &gt; 0 $ .</p>
<p>You want to photograph each parabola. To do this, for each parabola you need to choose a line that does not intersect this parabola and does not touch it. You can select the same line for different parabolas. Please find such a line for each parabola, or determine that there is no such line.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains $ 2 $ integers $ n $ and $ m $ ( $ 1 \le n, m \le 10^5 $ ) —the number of lines and parabolas, respectively.</p>
<p>Each of the next $ n $ lines contains one integer $ k $ ( $ |k| \le 10^8 $ ), denoting a line that is described with the equation $ y&#x3D;kx $ . The lines are not necessarily distinct, $ k $ can be equal to $ 0 $ .</p>
<p>Each of the next $ m $ lines contains $ 3 $ integers $ a $ , $ b $ , and $ c $ ( $ a, |b|, |c| \le 10^8 $ , $ a &gt; 0 $ ) — coefficients of equations of the parabolas $ ax^2+bx+c $ . The parabolas are not necessarily distinct.</p>
<p>It is guaranteed that the sum $ n $ over all test cases does not exceed $ 10^5 $ , and the sum $ m $ over all test cases also does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the answers for each parabola in the given order. If there is a line that does not intersect the given parabola and doesn’t touch it, print on a separate line the word “YES”, and then on a separate line the number $ k $ — the coefficient of this line. If there are several answers, print any of them. If the line does not exist, print one word “NO”.</p>
<p>You can output the answer in any case (upper or lower). For example, the strings “yEs”, “yes”, “Yes”, and “YES” will be recognized as positive responses.</p>
<p>The empty lines in the output in the example are given only for illustration, you do not need to output them (but you can).</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>-<span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span>-<span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"><span class="symbol">100000000 </span><span class="number">100000000</span> <span class="number">100000000</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>-<span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span>-<span class="number">2</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">NO</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>没有交点, 即是 $ax^2 + bx + c &#x3D; kx$ , 即是方程 $ax^2+(b-k)x+c &#x3D; 0$ 无解, 即是 $\triangle &lt;0$ , </p>
<p>$\triangle&#x3D; b^2-4ac-(2bk-k^2)$ , $a$ $b$ $c$ 已知, 要让 $\triangle$ 尽可能小, 让 $2bk-k^2$ 尽可能大就好了, 又因为这个是一个开口向下的二次函数, 我们可以用 <strong>二分法</strong> 找到使这个函数最大的 k , 然后代入 $\triangle$ 看是否小于0即可</p>
<p>k要记得去重, 记得要用 <code>long long</code> 去存, 会爆int</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> LL;	<span class="comment">//a, b, c, k 均到 1e8, int会爆, 又因为有负数, 不能用ULL, 只能用LL</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">LL k[N];</span><br><span class="line">LL n, m;</span><br><span class="line">LL a, b, c;</span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(LL t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (t &lt; <span class="number">0</span> || t &gt;= n) <span class="keyword">return</span> <span class="number">-1e9</span>;</span><br><span class="line">	t = k[t];</span><br><span class="line">	<span class="keyword">return</span> <span class="number">2</span> * b * t - t * t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; k[i];</span><br><span class="line">		<span class="comment">//sort 去重</span></span><br><span class="line">		<span class="built_in">sort</span>(k, k + n);</span><br><span class="line">		n = <span class="built_in">unique</span>(k, k + n) - k;	<span class="comment">//n是去重之后数组的长度</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line"></span><br><span class="line">			LL l = <span class="number">0</span>, r = n, ans = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">			&#123;</span><br><span class="line">				LL mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">				<span class="comment">//if (cal(mid) &gt;= cal(mid - 1) &amp;&amp; cal(mid) &gt;= cal(mid + 1))</span></span><br><span class="line">				<span class="comment">//&#123;</span></span><br><span class="line">				<span class="comment">//	ans = mid;</span></span><br><span class="line">				<span class="comment">//	break;</span></span><br><span class="line">				<span class="comment">//&#125;</span></span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">cal</span>(mid) &gt; <span class="built_in">cal</span>(mid - <span class="number">1</span>) &amp;&amp; <span class="built_in">cal</span>(mid) &lt; <span class="built_in">cal</span>(mid + <span class="number">1</span>)) l = mid + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> r = mid;</span><br><span class="line">			&#125;</span><br><span class="line">			LL res = b * b - <span class="number">4</span> * a * c - (<span class="built_in">cal</span>(l));</span><br><span class="line">			<span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl &lt;&lt; k[l] &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1802B/</url>
    <content><![CDATA[<h1 id="Settlement-of-Guinea-Pigs"><a href="#Settlement-of-Guinea-Pigs" class="headerlink" title="Settlement of Guinea Pigs"></a>Settlement of Guinea Pigs</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>Dasha 很喜欢豚鼠，她在 $n$ 天内要不是买豚鼠，要不是请医生来看豚鼠。</p>
<p>Dasha 和宠物店都无法分辨豚鼠的性别（思考人生），只能在医生来查看豚鼠的时候为这些豚鼠做性别鉴定。</p>
<p>为了豚鼠，Dasha 打算给它们买一些笼子，但宠物店里卖的笼子只能放最多 $2$ 只豚鼠。由于她不想让她的豚鼠遭受道德伤害，一个笼子里只能放同一种性别的豚鼠。</p>
<p>求 Dasha 最少需要买多少个笼子。</p>
<p>这个翻译由 @ztrztr 提供</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Dasha loves guinea pigs very much. In this regard, she decided to settle as many guinea pigs at home as possible and developed a plan for the next $ n $ days. Every day, she will either buy a new guinea pig or call a doctor to examine all her pets.</p>
<p>Unfortunately, the store where she was going to buy guinea pigs does not understand them. Therefore, it cannot determine their gender. Dasha can’t do it either. The only one who can help is a doctor.</p>
<p>To keep guinea pigs, aviaries are needed. Dasha plans to buy them in the same store. Unfortunately, only one species is sold there — a double aviary. No more than two guinea pigs can live in it.</p>
<p>Since Dasha does not want to cause moral injury to her pets — she will not settle two guinea pigs of different genders in one aviary.</p>
<p>Help Dasha calculate how many aviaries in the worst case you need to buy so that you can be sure that at no moment of time do two guinea pigs of different genders live in the same aviary.</p>
<p>As part of this task, we believe that guinea pigs have only two genders — male and female.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of input data contains one number $ t $ ( $ 1 \leqslant t \leqslant 10^5 $ ) — the number of input data sets.</p>
<p>The first line of each input data set contains one number $ n $ ( $ 1 \leqslant n \leqslant 10^5 $ ) — the number of days Dasha has a plan for.</p>
<p>The next line contains $ n $ numbers $ b_1, b_2, b_3, \ldots, b_n $ ( $ 1 \leqslant b_i \leqslant 2 $ ) — Dasha’s plan. If $ b_i &#x3D; 1 $ , then on the $ i $ th day, Dasha will buy a new guinea pig. If $ b_i &#x3D; 2 $ , then on the $ i $ th day, a doctor will come to Dasha and help determine the sex of all guinea pigs that Dasha already has.</p>
<p>It is guaranteed that the sum of $ n $ for all input data sets does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each set of input data, output one number — the minimum number of aviaries Dasha needs to buy so that no matter what the genders of the pigs turn out to be, we can settle them so that at no point in time do two guinea pigs of different genders live together.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">20</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">0</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">12</span><br><span class="line">9</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first set of input data, Dasha needs to put each guinea pig in a separate enclosure, since she does not know their gender.</p>
<p>In the second set of input data, Dasha will buy $ 0 $ guinea pigs, which means she will need $ 0 $ aviaries.</p>
<p>In the third set of input data, you even need $ 3 $ aviaries to put each guinea pig in a separate aviary before the doctor arrives at the $ 4 $ th day. When she finds out their gender, at least two guinea pigs will be of the same gender and they can be placed in one aviary, and the third in another aviary. Thus, she will have one free aviary in which she can settle a new guinea pig. So answer is $ 3 $ .</p>
<p>In the fourth set of input data, we show that $ 4 $ is the optimal answer.</p>
<p>To begin with, we note that the first four guinea pigs can be placed one at a time in an aviary. Then a doctor will come and determine their gender. Among these four guinea pigs there will be at least one pair of the same gender, because: either male guinea pigs are at least $ 2 $ , or they are not more than $ 1 $ , which means that the female is at least $ 3 $ . Now we can put this couple in one aviary, and the other two in separate ones. We will have one more empty aviary where we can put a new pig.</p>
<p>Now let’s show that the answer is at least $ 4 $ . Let’s say that among the first $ 4 $ guinea pigs, $ 3 $ are female and $ 1 $ is male. We need at least $ 3 $ aviaries to settle them. Then, when we buy a new guinea pig, we will need another aviary in which we will put it, since we do not know its gender.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>题目要求我们求出在任何情况下都适用的最少的笼子个数, 那我们就要考虑最坏的情况</p>
<ul>
<li><p>当豚鼠性别未知的时候, 肯定要一只豚鼠单独占用一个笼子</p>
</li>
<li><p>当豚鼠性别已知的时候, 我们要考虑在已知性别的豚鼠个数为 $k$ 的时候, 最多能用笼子个数记为 $q$</p>
<p>$k&#x3D;1$ 的时候, $q&#x3D;1$; $k&#x3D;2$ 的时候, 两个豚鼠性别不同时笼子最多, $q&#x3D;2$; 当 $k&#x3D;3$ 的时候, 肯定有两个豚鼠性别一样, $q&#x3D;2$; 当 $k&#x3D;4$ 的时候, 两个雄性用1个, 还有一个雌性用1个, 再来一个雄性的时候笼子数最多, $q&#x3D;3$; 按照这个思路: $k&#x3D;5$, $q&#x3D;3$; $k&#x3D;6$, $q&#x3D;4$</p>
<p>除了 $k$ 为1或者2的时候特殊, 其他 $k$ 为奇数的时候, $q&#x3D;\frac{k+1}{2}$ ; $k$ 为偶数, $q&#x3D;\frac{k+2}{2}$</p>
</li>
</ul>
<p>我们维护以下几个变量</p>
<ol>
<li>未知性别的豚鼠个数</li>
<li>已知性别的豚鼠个数</li>
<li>空的笼子个数</li>
<li>笼子总数</li>
</ol>
<p>遍历数组, 遇见1的时候未知豚鼠个数加1, 空笼子个数减一, 不够就要补一个空笼子, 笼子总数要加一; 遇见2的时候更新已知性别的豚鼠个数, 按照公式算出需要的笼子总数记为need, need小于现有笼子总数的时候, 更新空笼子&#x3D;现有笼子总数-need, need大于现有笼子总数时, 笼子总数加到need, 空笼子个数变成0</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> avb, num, unk, sum;	<span class="comment">//空的笼子 已知豚鼠 未知豚鼠 总的笼子</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		avb = num = unk = sum = <span class="number">0</span>;	<span class="comment">//多例记得清空</span></span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">			<span class="comment">//未知豚鼠个数加一, 需要一个空的笼子, 不够要补上</span></span><br><span class="line">			<span class="keyword">if</span> (t == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				unk++;</span><br><span class="line">				<span class="keyword">if</span> (avb &lt; <span class="number">1</span>) avb++, sum++;</span><br><span class="line"></span><br><span class="line">				avb--;		<span class="comment">//现在这个笼子被未知豚鼠占用了</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//更新已知豚鼠个数, 算出笼子, 可能空笼子会多, 也可能空笼子会少</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				num += unk;</span><br><span class="line">				unk = <span class="number">0</span>;	<span class="comment">//记得要清空</span></span><br><span class="line">				<span class="type">int</span> need = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">if</span> (num == <span class="number">1</span>) need = <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (!num) need = <span class="number">0</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) need = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">2</span>) need = (num + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) need = (num + <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">				<span class="comment">//需要的比总的笼子个数少</span></span><br><span class="line">				<span class="keyword">if</span> (need &lt;= sum)</span><br><span class="line">				&#123;</span><br><span class="line">					avb = sum - need;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					avb = <span class="number">0</span>, sum = need;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout <span class="comment">/*&lt;&lt; &quot;****&quot;*/</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1805D/</url>
    <content><![CDATA[<h1 id="A-Wide-Wide-Graph"><a href="#A-Wide-Wide-Graph" class="headerlink" title="A Wide, Wide Graph"></a>A Wide, Wide Graph</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定一棵 $n$（$2\leq n\leq 10^5$）个节点的无根树，对于每个 $k$（$1\leq k \leq n$），定义一个无向图 $G_k$，其中由边连接的两个节点 $u$ 和 $v$ 的距离至少为 $k$。请你计算 $G_k$ 的连通块个数。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>第一行包含整数 $n$。</p>
<p>接下来 $n-1$ 行，每行包含两个整数 $u$ 和 $v$，表示树上的一条无向边。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>输出共 $n$ 行，每行一个整数，表示 $G_k$ 的连通块个数。</p>
<h2 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h2><p>$2\leq n\leq 10^5$</p>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>第一个样例中，当$k&#x3D;1$时，所有的点都连通；当$k&#x3D;4$时，只有$(4,6)$和$(5,6)$两条边连通，所以连通块个数为4。</p>
<p>第二个样例中，当$k&#x3D;3$时，节点1、4、5构成一个连通块，其余两个节点分别为一个连通块。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a tree (a connected graph without cycles) with $ n $ vertices.</p>
<p>Consider a fixed integer $ k $ . Then, the graph $ G_k $ is an undirected graph with $ n $ vertices, where an edge between vertices $ u $ and $ v $ exists if and only if the distance between vertices $ u $ and $ v $ in the given tree is at least $ k $ .</p>
<p>For each $ k $ from $ 1 $ to $ n $ , print the number of connected components in the graph $ G_k $ .</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains the integer $ n $ ( $ 2 \le n \le 10^5 $ ) — the number of vertices in the graph.</p>
<p>Each of the next $ n-1 $ lines contains two integers $ u $ and $ v $ ( $ 1 \le u, v \le n $ ), denoting an edge between vertices $ u $ and $ v $ in the tree. It is guaranteed that these edges form a valid tree.</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>Output $ n $ integers: the number of connected components in the graph $ G_k $ for each $ k $ from $ 1 $ to $ n $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>

<h2 id="样例-2"><a href="#样例-2" class="headerlink" title="样例 #2"></a>样例 #2</h2><h3 id="样例输入-2"><a href="#样例输入-2" class="headerlink" title="样例输入 #2"></a>样例输入 #2</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-2"><a href="#样例输出-2" class="headerlink" title="样例输出 #2"></a>样例输出 #2</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>引入1</strong>: 对树上任意一个点, 与之距离最远的每一个点, 至少有一个直径的端点</p>
<p>题目要求当两个点距离 $\ge k$ 的时候这两个点才可以连通, 我们就考虑 $k$ 最大可以取到哪里, 树上最远的距离就是直径 $d$ , 那么当 $k &gt; d$ 的时候所有点自己是一个连通块</p>
<p>当 $k &#x3D; 1$ 的时候, 所有的点属于一个连通块, 当 $k &#x3D; 2$ 的时候, 那些距离最远取到1的点要被摘出去, 然后剩下合法的点属于一个连通块, 也就是说有这样一个性质: <strong>最多只有一个包含多个点的连通块</strong> </p>
<p>记点 $i$ 的最远距离为 $D_i$ , 我们可以在 dfs 的时候预处理出来有多少个点最远距离是 $D_i$, 且 $k &#x3D; 1$ 时, 连通块的数量是1, 我们就可以一路推下去, $k &#x3D; D$ 的时候, 连通块数量 +&#x3D; D对应的点的数量</p>
<p><strong>引入2</strong>: 求树的直径的方法</p>
<ul>
<li><p>先从任意点 $t$ 开始 dfs, 找到离 $t$ 最远的点 $x$</p>
</li>
<li><p>然后从 $x$ 开始 dfs, 找到离 $x$ 最远的点 $y$</p>
</li>
</ul>
<p>这样 $x$ 和 $y$ 就是直径的两个端点, 在本题中 dfs 时顺便还可以求出任意点 $i$ 到 $x$ 或者 $y$ 的距离</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], idx;		<span class="comment">//存图</span></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> p;	<span class="comment">//直径端点</span></span><br><span class="line"><span class="type">int</span> dis1[N], dis2[N];	<span class="comment">//dis1[i]表示点i到直径其中一个端点的距离, dis2同理</span></span><br><span class="line"><span class="type">int</span> cnt[N];		<span class="comment">//cnt[1]表示D为1的点有多少个</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis1[x] = dis1[last] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">if</span> (dis1[x] &gt; dis1[p]) p = x;	<span class="comment">//找出距离最远的点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = e[i];</span><br><span class="line">		<span class="keyword">if</span>(t != last)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs1</span>(t, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> last)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	dis2[x] = dis2[last] + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = h[x]; i != <span class="number">-1</span>; i = ne[i])</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> t = e[i];</span><br><span class="line">		<span class="keyword">if</span> (t != last)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">dfs2</span>(t, x);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="keyword">sizeof</span> h);</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b;</span><br><span class="line">		cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		<span class="built_in">add</span>(a, b), <span class="built_in">add</span>(b, a);	<span class="comment">//无向边</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//两次dfs求直径</span></span><br><span class="line">	<span class="built_in">dfs1</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="built_in">dfs1</span>(p, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">//另一个dfs求到一个端点的距离, 另一个距离在第一种dfs中已经求出来了</span></span><br><span class="line">	<span class="built_in">dfs2</span>(p, <span class="number">0</span>);		<span class="comment">//此时p已经更新为另一个端点了</span></span><br><span class="line">	<span class="comment">//预处理每个D对应几个点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i != p)		<span class="comment">//两个端点不能重复计算, cnt[i]表示要摘出来的点的个数, 摘剩一个点那个点就不用摘了</span></span><br><span class="line">			cnt[<span class="built_in">max</span>(dis1[i], dis2[i]) - <span class="number">1</span>]++;	<span class="comment">//dfs的开始点距离应该是0, 所以实际距离要减去1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//枚举k</span></span><br><span class="line">	<span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; k++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ans += cnt[k - <span class="number">1</span>];</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1806B/</url>
    <content><![CDATA[<h1 id="Mex-Master"><a href="#Mex-Master" class="headerlink" title="Mex Master"></a>Mex Master</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定长度为 $n$ 的序列 $a$，规定 $a$ 的权值为 $\text{mex}{a_1+a_2,a_2+a_3,\cdots,a_{n-1}+a_n}$（$\text{mex}$ 是指一个非负整数序列中最小的未在序列中出现的整数）。现在 $a$ 可以任意排列，求 $a$ 的最小权值。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given an array $ a $ of length $ n $ . The score of $ a $ is the MEX $ ^{\dagger} $ of $ [a_1+a_2,a_2+a_3,\ldots,a_{n-1}+a_n] $ . Find the minimum score of $ a $ if you are allowed to rearrange elements of $ a $ in any order. Note that you are not required to construct the array $ a $ that achieves the minimum score.</p>
<p> $ ^{\dagger} $ The MEX (minimum excluded) of an array is the smallest non-negative integer that does not belong to the array. For instance:</p>
<ul>
<li>The MEX of $ [2,2,1] $ is $ 0 $ , because $ 0 $ does not belong to the array.</li>
<li>The MEX of $ [3,1,0,1] $ is $ 2 $ , because $ 0 $ and $ 1 $ belong to the array, but $ 2 $ does not.</li>
<li>The MEX of $ [0,3,1,2] $ is $ 4 $ because $ 0 $ , $ 1 $ , $ 2 $ , and $ 3 $ belong to the array, but $ 4 $ does not.</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1\le t\le 10^4 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2\le n\le 2\cdot10^5 $ ).</p>
<p>The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 2\cdot 10^5 $ ).</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the minimum score of $ a $ after rearranging the elements of $ a $ in any order.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">0</span> <span class="number">3</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, it is optimal to rearrange $ a $ as $ [0,0] $ , the score of this array is the MEX of $ [0+0]&#x3D;[0] $ , which is $ 1 $ .</p>
<p>In the second test case, it is optimal to rearrange $ a $ as $ [0,1,0] $ , the score of this array is the MEX of $ [0+1,1+0]&#x3D;[1,1] $ , which is $ 0 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>已知序列元素都大于等于0, 要求出最小的 ans</p>
<p>ans 最小就是0, 先考虑什么时候 ans 可以是0, 相邻元素和全部都不是0的时候, ans 为0, 什么时候相邻元素和不为0呢? 对于序列元素来说</p>
<ul>
<li><p>没有0的时候, 相邻元素和不会有0</p>
</li>
<li><p>有0的时候呢, 要想相邻元素和不出现0, 那么一个0肯定要搭配一个非0的数</p>
<p>我们考虑 0 a 0 b 0 这种情况, 我们不难观察出, 如果0的个数最多也就比非0数的个数多出1, 不然相邻元素和肯定会出现0</p>
</li>
</ul>
<p>那我们就得出: 0的个数比非零数的个数多出来k个, 当 $k\le1$ 的时候, 能构造出相邻元素和没有0的序列, ans为0</p>
<p>反之就是相邻元素和肯定会出现0的情况, 那么 ans 最小也就是1, 什么时候 ans 可以为1呢(在相邻元素和出现0的前提下), 那就是相邻元素和不会有1</p>
<ul>
<li><p>序列全为0 或者 序列里没出现1的时候, 相邻元素和不会有1, ans 肯定是1</p>
</li>
<li><p>序列里出现1了, 那么要想相邻元素和没有1, 1就肯定不能和1挨着, </p>
<p>如果序列里有大于1的数, 就可以构造出 <code>1 1 3 0 0 0 0 0</code> 的情况, 此时ans为1, 反之就是序列只有0和1, 肯定会出现1, 那么 ans 最小也只能是2, 肯定也能构造出 ans &#x3D; 2 的情况, 比如 <code>0 0 1 0 1 0</code> 这样</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(b, <span class="number">0</span>, <span class="keyword">sizeof</span> <span class="number">0</span>);		<span class="comment">//多例要清空</span></span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="type">bool</span> st = <span class="literal">false</span>; 	<span class="comment">//有没有出现大于1的数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">			<span class="keyword">if</span> (a &gt; <span class="number">1</span>) st = <span class="literal">true</span>;</span><br><span class="line">			b[a]++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!b[<span class="number">0</span>])	<span class="comment">//0没出现 肯定能构造大于0的</span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//可以构造出相邻元素和没有0的</span></span><br><span class="line">			<span class="keyword">if</span> (b[<span class="number">0</span>] - (n - b[<span class="number">0</span>]) &lt;= <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; endl;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">//全为0 ans = 1</span></span><br><span class="line">				<span class="keyword">if</span> (b[<span class="number">0</span>] == n)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果有比1大的数, 可以使得相邻元素和除了0都大于1, 例如1 1 3 0 0 0 0 0</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (st)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;1&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//没有比1大的数, 那肯定有一个1跟0相邻, </span></span><br><span class="line">                <span class="comment">//相邻元素和里肯定有0和1, 那就只能构建出没有2的, ans是2</span></span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(!st)</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="string">&quot;2&quot;</span> &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1808A/</url>
    <content><![CDATA[<h1 id="Lucky-Numbers"><a href="#Lucky-Numbers" class="headerlink" title="Lucky Numbers"></a>Lucky Numbers</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>定义一个数的幸运值为这个数中最大数字与最小数字的差。例如数字 $142857$ 的幸运值为 $8-1&#x3D;7$ 。现给出 $T$ 组区间 $[l,r]$ ，对于每组数据输出区间中幸运值最大的数字，若有多种答案输出一种即可。 $T \leq 10\ 000$，$1 \leq l \leq r \leq 10^6$ 。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Olympus City recently launched the production of personal starships. Now everyone on Mars can buy one and fly to other planets inexpensively.</p>
<p>Each starship has a number —some positive integer $ x $ . Let’s define the luckiness of a number $ x $ as the difference between the largest and smallest digits of that number. For example, $ 142857 $ has $ 8 $ as its largest digit and $ 1 $ as its smallest digit, so its luckiness is $ 8-1&#x3D;7 $ . And the number $ 111 $ has all digits equal to $ 1 $ , so its luckiness is zero.</p>
<p>Hateehc is a famous Martian blogger who often flies to different corners of the solar system. To release interesting videos even faster, he decided to buy himself a starship. When he came to the store, he saw starships with numbers from $ l $ to $ r $ inclusively. While in the store, Hateehc wanted to find a starship with the luckiest number.</p>
<p>Since there are a lot of starships in the store, and Hateehc can’t program, you have to help the blogger and write a program that answers his question.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains an integer $ t $ ( $ 1 \le t \le 10,000 $ ) —the number of test cases.</p>
<p>Each of the following $ t $ lines contains a description of the test case. The description consists of two integers $ l $ and $ r $ ( $ 1 \le l \le r \le 10^6 $ ) — the largest and smallest numbers of the starships in the store.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Print $ t $ lines, one line for each test case, containing the luckiest starship number in the store.</p>
<p>If there are several ways to choose the luckiest number, output any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">59 </span><span class="number">63</span></span><br><span class="line"><span class="symbol">42 </span><span class="number">49</span></span><br><span class="line"><span class="symbol">15 </span><span class="number">15</span></span><br><span class="line"><span class="symbol">53 </span><span class="number">57</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">100</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">60</span><br><span class="line">49</span><br><span class="line">15</span><br><span class="line">57</span><br><span class="line">90</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>Let’s look at two test examples:</p>
<ul>
<li>the luckiness of the number $ 59 $ is $ 9 - 5 &#x3D; 4 $ ;</li>
<li>the luckiness of $ 60 $ equals $ 6 - 0 &#x3D; 6 $ ;</li>
<li>the luckiness of $ 61 $ equals $ 6 - 1 &#x3D; 5 $ ;</li>
<li>the luckiness of $ 62 $ equals $ 6 - 2 &#x3D; 4 $ ;</li>
<li>the luckiness of $ 63 $ is $ 6 - 3 &#x3D; 3 $ .</li>
</ul>
<p> Thus, the luckiest number is $ 60 $ .In the fifth test example, the luckiest number is $ 90 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们能发现这个幸运数最大就是 $9 &#x3D; 9 - 0$ , 什么时候肯定会出现 $9$ 和 $0$ 呢</p>
<p>当 r - l &gt; 100 的时候, 在 l 和 r 至少有一个数 十位和个位分别是 9 和 0, 就就比如 132 + 1 + 2… 一直加加加, 加到某个数时肯定会到 200 而在此之前就会出现 190, 其他的数同理</p>
<p>当 r - l &lt; 100 的时候, 我们遍历所有数, 计算这个数的幸运值即可, 因为 r, l 最多也就 $10^6$ , 找出最大数和最小数最多也就6次, 100个数也就是600次, t是$10^4$, 最多也就是$6\times10^4$, 不会超时</p>
<p>代码太简单就不写了</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1808B/</url>
    <content><![CDATA[<h1 id="Playing-in-a-Casino"><a href="#Playing-in-a-Casino" class="headerlink" title="Playing in a Casino"></a>Playing in a Casino</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>现有一种在太阳系中广为人知的卡牌游戏，叫做“Galaxy Luck”。</p>
<p>在每场游戏中，会有 $n$ 位玩家，每人 $1$ 张卡片，每张卡片上有 $m$ 个数字，每两位玩家会进行一次游戏，并且这两人之间只进行一次。例如：有四位玩家，第一位对第二位，第一位对第三位，第一位对第四位，第二位对第三位，第二位对第四位，第三位对第四位，共 $6$ 次游戏。</p>
<p>这种游戏有特定的获胜规则，赢家所获得的点数也有特定的计算方式；由于获胜规则很复杂，这里不会讲述。但更值得注意的是，应该给赢家多少点数。其遵循以下计算方式：第一位玩家有数字 $a_1,a_2,…,a_m$，第二位玩家有数字 $b_1,b_2,…,b_m$，那么赢家会得到的点数为：$|a_1-b_1|+|a_2-b_2|+\cdot\cdot\cdot+|a_m-b_m|$，其中， $|x|$ 代表 $x$ 的绝对值。</p>
<p>为了确定奖池的大小，需要编写一个程序来计算总点数。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>每组中数据中包含多行。</p>
<p>输入中的第一行包含 $1$ 个整数 $t(1\le t\le1000)$，是总组数。接下来输入 $t$ 组。</p>
<p>每组中，第一行包含两个整数 $n$ 和 $m (1\le n\cdot m\le3\cdot 10^5)$，是卡片总数以及每张卡片上的数字数目。</p>
<p>接下来 $n$ 行，每行都包含 $m$ 个整数 $c_{i,j}(1\le c_{i,j}\le 10^6)$ ，是第 $i$ 张卡片上的数字。</p>
<p>数据保证所有的 $n\cdot m$ 都不会超过 $3\cdot 10^5$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每组数据，打印 $1$ 个数字，用换行隔开，代表每场游戏的赢家点数总和。</p>
<h3 id="说明-提示"><a href="#说明-提示" class="headerlink" title="说明&#x2F;提示"></a>说明&#x2F;提示</h3><p>例如第一组数据：</p>
<p>第一位对第二位玩家，胜者得到 $|1-7|+|4-9|+|2-2|+|8-1|+|5-4|&#x3D;19$ 点。</p>
<p>第一位对第三位玩家，胜者得到 $|1-3|+|4-8|+|2-5|+|8-3|+|5-1|&#x3D;18$ 点。</p>
<p>第二位对第三位玩家，胜者得到 $|7-3|+|9-8|+|2-5|+|1-3|+|4-1|&#x3D;13$ 点。</p>
<p>总点数为 $19+18+13&#x3D;50$ 点。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>In this game, there is a deck that consists of $ n $ cards. Each card has $ m $ numbers written on it. Each of the $ n $ players receives exactly one card from the deck.</p>
<p>Then all players play with each other in pairs, and each pair of players plays exactly once. Thus, if there are, for example, four players in total, then six games are played: the first against the second, the first against the third, the first against the fourth, the second against the third, the second against the fourth and the third against the fourth.</p>
<p>Each of these games determines the winner in some way, but the rules are quite complicated, so we will not describe them here. All that matters is how many chips are paid out to the winner. Let the first player’s card have the numbers $ a_1, a_2, \dots, a_m $ , and the second player’s card — $ b_1, b_2, \dots, b_m $ . Then the winner of the game gets $ |a_1 - b_1| + |a_2 - b_2| + \dots + |a_m - b_m| $ chips from the total pot, where $ |x| $ denotes the absolute value of $ x $ .</p>
<p>To determine the size of the total pot, it is necessary to calculate the winners’ total winnings for all games. Since there can be many cards in a deck and many players, you have been assigned to write a program that does all the necessary calculations.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test consists of several test cases. The first line contains one integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains two integers $ n $ and $ m $ ( $ 1 \le n \cdot m \le 3\cdot 10^5 $ ) — the number of cards in the deck and the count of numbers on the one card.</p>
<p>Each of the following $ n $ lines of the test case set contains $ m $ integers $ c_{i,j} $ ( $ 1 \le c_{i,j} \le 10^6 $ ) — a description of the $ i $ -th card.</p>
<p>It is guaranteed that the total $ n \cdot m $ in all tests does not exceed $ 3 \cdot 10^5 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print one number — the total amount of winnings from all games.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span> <span class="number">2</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">9</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">8</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">15</span> <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">50</span><br><span class="line">0</span><br><span class="line">31</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>Consider the first test case.</p>
<p>In the game between the first and second player, the winner receives $ |1-7| + |4-9| + |2-2| + |8-1| + |5-4| &#x3D; 19 $ chips.</p>
<p>In the game between the first and third player, the winner receives $ |1-3| + |4-8| + |2-5| + |8-3| + |5-1| &#x3D; 18 $ in chips.</p>
<p>In the game between the second and third player, the winner receives $ |7-3| + |9-8| + |2-5| + |1-3| + |4-1| &#x3D; 13 $ chips.</p>
<p>The total is $ 19 + 18 + 13 &#x3D; 50 $ chips.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>有 n 行 m 列, 要求所有点数的总和, 对于每一列来说就是选两个数相减的绝对值的总和, 即 $ \sum_{1 \le i &lt; j \le m} \left | a_i - a_j \right | $, 反正是选两个数相减不重不漏, 那么我们就算对于一列进行排序对结果不会有任何影响</p>
<p>我们将每一列升序排列, 对于任意 $j &gt; i$ 就有 $d_{ij}&#x3D;a_j-a_i&#x3D;a_{i+1}-a_i + a_{i+2}-a_i+…+a_j-a_{j-1}$ , 对于一列上所有的 $d_{ij}$ 而言都可以转换为在这之前相邻两数之差的总和, 我们就要计算相邻两数之差的出现次数, 也即是对答案贡献</p>
<p>观察发现, 比如对于 $d_{23}&#x3D;a_3-a_2$ , $a_3-a_1$ 会用到, $a_3-a_2$ 会用到, $a_4-a_2$ 会用到, $a_4-a_1$ 也会用到, 观察一下就可以发现: 对于 $d_{23}$ 而言, 会被用到的次数是 $(n - 2)\times2$ , 那么 $d_{ij}$ 对于答案的贡献是就是 $(n-i)\times i$ 次</p>
<p>那我们就枚举 m 列, 对每一列升序排序, 然后计算相邻两个数的差, 再乘上贡献次数, 最后就可以求出答案</p>
<p><strong>!</strong>: 答案可能会爆 <code>int</code> , 要用 <code>long long</code> 存, 计算过程也要以 <code>long long</code> 去计算</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];</span><br><span class="line"><span class="type">int</span> a[N], tt = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		tt = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			v[i].<span class="built_in">clear</span>();	<span class="comment">//多例要记得清空</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">			&#123;	</span><br><span class="line">				<span class="type">int</span> x; cin &gt;&gt; x;</span><br><span class="line">				v[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//枚举每一列</span></span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			tt = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				a[++tt] = v[j][i];</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">sort</span>(a + <span class="number">1</span>, a + tt + <span class="number">1</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; tt; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans += <span class="built_in">ll</span>(a[i + <span class="number">1</span>] - a[i]) * i * (n - i);	<span class="comment">//这里也要转成 ll</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1814A/</url>
    <content><![CDATA[<h1 id="Coins"><a href="#Coins" class="headerlink" title="Coins"></a>Coins</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p><strong>本题一共有 $t$ 组数据。</strong></p>
<p>每组数据包含两个整数 $n$ 和 $k$，如果存在两个非负整数 $x,y$，满足 $2\times x+k\times y&#x3D;n$，输出 <code>YES</code>，否则输出 <code>NO</code></p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>In Berland, there are two types of coins, having denominations of $ 2 $ and $ k $ burles.</p>
<p>Your task is to determine whether it is possible to represent $ n $ burles in coins, i. e. whether there exist non-negative integers $ x $ and $ y $ such that $ 2 \cdot x + k \cdot y &#x3D; n $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>The only line of each test case contains two integers $ n $ and $ k $ ( $ 1 \le k \le n \le 10^{18} $ ; $ k \ne 2 $ ).</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print YES if it is possible to represent $ n $ burles in coins; otherwise, print NO. You may print each letter in any case (YES, yes, Yes will all be recognized as positive answer, NO, no and nO will all be recognized as negative answer).</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, you can take one coin with denomination $ 2 $ and one coin with denomination $ k &#x3D; 3 $ .</p>
<p>In the second test case, you can take three coins with denomination $ 2 $ . Alternatively, you can take six coins with denomination $ k &#x3D; 1 $ .</p>
<p>In the third test case, there is no way to represent $ 7 $ burles.</p>
<p>In the fourth test case, you can take one coin with denomination $ k &#x3D; 8 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>问我们能否用面值为2的硬币和面值为k的硬币表示 n , 即是问是否存在非负整数 x 和 y 使得 $2\times x + k \times y &#x3D; n$ , 如果存在, 那么其中y个面值为硬币肯定可以拆出 x’ 个面值为2的硬币, 余数为 y’ , 我们只需要从0到1枚举 y’ , 看看 $n - y’\times k$ 是否是个偶数, 即是否可以被二整除即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		ULL n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (i == <span class="number">2</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ULL v = n - i * k;</span><br><span class="line">			<span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1814B/</url>
    <content><![CDATA[<h1 id="Long-Legs"><a href="#Long-Legs" class="headerlink" title="Long Legs"></a>Long Legs</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给你一个无限大小的棋盘，一个机器人初始位置为 $(0,0)$，初始每次可移动的长度为 $1$。<br>对于一个当前在 $(x,y)$ 的机器人，且它当前的可移动长度为 $m$（初始为 $1$)。则它可以耗费一个时间进行如下操作：<br>$\qquad$ 1. 移动到 $(x+m,y)$。<br>$\qquad$ 2. 移动到 $(x,y+m)$。<br>$\qquad$ 3.使得 $m&#x3D;m+1$。<br>注意：在当前位置使得 $m&#x3D;m+1$ 后会影响后面的操作。 </p>
<p>现在给你两个正整数 $a,b(1 \leq a,b \leq 10^9)$，问机器人最少需要多少单位时间可以到达 $(a,b)$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A robot is placed in a cell $ (0, 0) $ of an infinite grid. This robot has adjustable length legs. Initially, its legs have length $ 1 $ .</p>
<p>Let the robot currently be in the cell $ (x, y) $ and have legs of length $ m $ . In one move, it can perform one of the following three actions:</p>
<ul>
<li>jump into the cell $ (x + m, y) $ ;</li>
<li>jump into the cell $ (x, y + m) $ ;</li>
<li>increase the length of the legs by $ 1 $ , i. e. set it to $ m + 1 $ .</li>
</ul>
<p>What’s the smallest number of moves robot has to make to reach a cell $ (a, b) $ ?</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases.</p>
<p>The only line of each test case contains two integers $ a $ and $ b $ ( $ 1 \le a, b \le 10^9 $ ) — the ending cell.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print a single integer — the smallest number of moves the robot is required to make to reach a cell $ (a, b) $ from a cell $ (0, 0) $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first testcase, the robot can first jump to $ (0, 1) $ , then to $ (1, 1) $ . If it ever increases the length of its legs, it will only be able to jump past $ (1, 1) $ .</p>
<p>In the second testcase, the robot can jump to $ (1, 0) $ , then increase the length of its length to $ 2 $ and jump three times to reach $ (1, 6) $ .</p>
<p>In the third testcase, the robot can increase the length of its legs three times to make it $ 4 $ . Then jump to $ (0, 4) $ . Then jump twice to reach $ (8, 4) $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>第三种操作进行次数太少时, m 太小, 需要的时间就会增加, 但如果 m 过大, 第三种操作浪费了太多的步数, 也会导致时间边长</p>
<p>我们的策略是: 先选好一个合适的 m , 然后以这个 m 来跳格子</p>
<p>终点是 (a, b) , 以x轴为例: </p>
<ul>
<li>当 a 可以被我们选好的 m 整除时, 跳到 (a, 0) 的步数是 $\frac{a}{m}$ , </li>
<li>当 a 不能被整除时, 我们以 m 去跳最多能跳到 $\left [  \frac{a}{m}\right ]$ 位置, 剩下的部分一定小于 m , 记为 k , 我们在增加步长的过程中肯定会出现 m &#x3D; k 的时候, 我们只需要在这个时候以步长 k 跳一次格子即可, 跳到 (a, 0) 的步数就是 $\left [  \frac{a}{m}\right ] + 1$</li>
</ul>
<p>对于y轴同理, 能整除就是 $\frac{b}{m}$ , 不能整除就是 $\left [  \frac{b}{m}\right ] + 1$</p>
<p>再加上增加步长需要的操作次数 (m - 1) , 总的操作次数就是: $x到a的步数 + y到b的步数 + (m - 1)$ </p>
<p>我们只需要1开始枚举合适的步长 m , m 最大是不会超过 $3 \times 10^5$ 的</p>
<p>为什么 m 最大不超过 $3 \times 10^5$ 呢? </p>
<p>我们发现, a和b均不能被m整除时的总操作次数 和 a和b均可以被m整除的总操作次数之间也就差2, 随便选一种来讨论</p>
<p>已知: $m + n \le 2 \sqrt{mn}$ , 当且仅当 $m &#x3D; n$ 时取到等于号</p>
<p>那么对于总操作次数来说有 $\frac{a + b}{m}  + m - 1\le 2\sqrt{\frac{a + b}{m}}-1$ , 要想操作次数取最小, 即是 $\frac{a+b}{m} &#x3D; m$ , 即$m &#x3D; \sqrt{a+b}$ </p>
<p>当 a &#x3D; b &#x3D; $10^9$ 时, m不过也就是 $\sqrt{2} \times 10^\frac{9}{2}$ , 是不会超时的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> ans = N;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t = (a / i) + (a % i != <span class="number">0</span>) + (b / i) + (b % i != <span class="number">0</span>) + i - <span class="number">1</span>;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, t);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1816A/</url>
    <content><![CDATA[<h1 id="Ian-Visits-Mary"><a href="#Ian-Visits-Mary" class="headerlink" title="Ian Visits Mary"></a>Ian Visits Mary</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>$\textrm{lan}$ 和 $\textrm{Mary}$ 是生活在笛卡尔坐标系格点上的青蛙，$\textrm{lan}$ 在 $(0,0)$，而 $\textrm{Mary}$ 在 $(a,b)$。</p>
<p>$\textrm{lan}$ 想在 笛卡尔坐标系上跳来跳去去访问 $\textrm{Mary}$。每一秒，他会从当前位置 $(x_p,y_p)$ 跳到整点 $(x_q,y_q)$，使得若用一条线段连接 $(x_p,y_p)$ 和 $(x_q,y_q)$，没有整点在这条线段上。</p>
<p>$\textrm{lan}$ 想尽快见到 $\textrm{Mary}$，所以他想用最多两次跳跃到 $(a,b)$。不幸的是，$\textrm{lan}$ 不太会数学，你能帮帮他吗？</p>
<p>整点被定义为 $x$ 坐标和 $y$ 坐标都是整数的点。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行包含一个整数 $t$ ( $1\le t\le 500$ )，表示测试数据的数量。</p>
<p>对于每一个数据：</p>
<p>只有一行包含两个正整数 $a,b$ ( $1\le a,b\le 10^9$ )，含义如题面所示。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每一个数据：</p>
<p>第一行是一个正整数 $n$ ( $1\le n\le 2$ )，表示 $\textrm{lan}$ 需要几次跳跃访问 $\textrm{Mary}$。<strong>注意：你不需要让 $n$ 最小。</strong></p>
<p>下面是 $n$ 行，在第 $i$ 行有用空格分开的两个整数 $x_i,y_i$ ( $0\le x_i,y_i\le 10^9$ )，表示 $\textrm{lan}$ 第 $i$ 次会跳跃到 $(x_i,y_i)$。必须满足 $x_n&#x3D;a,y_n&#x3D;b$。</p>
<p>$\textrm{lan}$ 每次跳转后的位置不需要是不同的。</p>
<p>如果有多组解，输出任意一个。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Ian and Mary are frogs living on lattice points of the Cartesian coordinate plane, with Ian living on $ (0,0) $ and Mary living on $ (a,b) $ .</p>
<p>Ian would like to visit Mary by jumping around the Cartesian coordinate plane. Every second, he jumps from his current position $ (x_p, y_p) $ to another lattice point $ (x_q, y_q) $ , such that no lattice point other than $ (x_p, y_p) $ and $ (x_q, y_q) $ lies on the segment between point $ (x_p, y_p) $ and point $ (x_q, y_q) $ .</p>
<p>As Ian wants to meet Mary as soon as possible, he wants to jump towards point $ (a,b) $ using at most $ 2 $ jumps. Unfortunately, Ian is not good at maths. Can you help him?</p>
<p>A lattice point is defined as a point with both the $ x $ -coordinate and $ y $ -coordinate being integers.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first and only line of each test case contains two integers $ a $ and $ b $ ( $ 1\le a,b\le 10^9 $ ) — the coordinates of the lattice point where Mary lives.</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print an integer $ n $ ( $ 1 \le n \le 2 $ ) on the first line, denoting the number of jumps Ian uses in order to meet Mary. Note that you do not need to minimize the number of jumps.</p>
<p>On the $ i $ -th line of the next $ n $ lines, print two integers $ 0 \le x_i,y_i \le 10^9 $ separated by a space, denoting Ian’s location $ (x_i,y_i) $ after the $ i $ -th jump. $ x_n &#x3D; a $ , $ y_n &#x3D; b $ must hold.</p>
<p>Ian’s initial location and his locations after each of the $ n $ jumps need not be distinct.</p>
<p>If there are multiple solutions, output any.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2022 </span><span class="number">2023</span></span><br><span class="line"><span class="symbol">1000000000 </span><span class="number">1000000000</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">2022 </span><span class="number">2023</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">69420420 </span><span class="number">469696969</span></span><br><span class="line"><span class="symbol">1000000000 </span><span class="number">1000000000</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从 (0, 0) 到 (x - 1, 1) 再到 (x, y) 肯定合法</p>
<p>也即是在 长为1, 宽为m 或者 宽为1, 长为m 的矩形内连接对角线, 除了端点, 没有别的点在对角线上</p>
<p>代码太简单不写了</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1816B/</url>
    <content><![CDATA[<h1 id="Grid-Reconstruction"><a href="#Grid-Reconstruction" class="headerlink" title="Grid Reconstruction"></a>Grid Reconstruction</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p><strong>题目描述</strong></p>
<p>在一个 $2×n$ 的网格中 （$n$ 为偶数），标记 $1,2,\ldots,2n$，但每个数只能被使用 $1$ 次。</p>
<p>某条路径是从 $(1,1)$ 开始的单元序列，随后不断地向下走或向右走，直到到达 $(2,n)$。注意：这条路径不能超出网格的边界。</p>
<p>通过这条路径的成本是这条路径所通过的单元格上的数字交替和，即，设路径上的数为 $a,a_1,a_2,\ldots,a_k$（它是第几个被标记到的，它的下标就是几），则通过这条路径的成本就是 $ a_1 - a_2 + a_3 - a_4 + \ldots &#x3D; \sum_{i&#x3D;1}^k a_i \cdot (-1)^{i+1} $。</p>
<p>你需要求一个在网格中标记 $1,2,…,2n$ 的方案，最大化成本最小的路径的成本。如果有多个答案，你可以输出任意一个。本题中，每个测试点包含 $t$ 组数据。</p>
<p><strong>输入格式</strong></p>
<p>第一行包含 $t$（$t$ 是测试数据组数）。</p>
<p>随后的 $t$  行，每行给出一个 $n$，表示网格的边长。<br>数据保证 $n\le10^5$。</p>
<p><strong>输出格式</strong></p>
<p>共 $2t$ 行，每组测试数据两行，每行包含 $n$ 个整数，表示所需的网格。如果有多个答案，你可以输出任意一个。</p>
<p><strong>说明&#x2F;提示</strong></p>
<p>在第一组测试数据中，只有两条从 $(1,1)$ 到 $(2,2)$ 的路径，它们的成本分别是 $3-1+4&#x3D;6$ 和 $3-2+4&#x3D;5$，其中成本更小的方案是 $5$，这是最优的方案。</p>
<p>在第二组测试数据中，有四条从 $(1,1)$ 到 $(2,4)$ 的路径，它们的成本分别是 $8-1+5-3+7&#x3D;16$，$8-2+5-3+7&#x3D;15$，$8-2+6-3+7&#x3D;16$ 和 $8-2+6-4+7&#x3D;15$，其中成本最小的一种方案是 $15$，这是最优的方案。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Consider a $ 2 \times n $ grid, where $ n $ is an even integer. You may place the integers $ 1, 2, \ldots, 2n $ on the grid, using each integer exactly once.</p>
<p>A path is a sequence of cells achieved by starting at $ (1, 1) $ , then repeatedly walking either downwards or to the right, and stopping when $ (2, n) $ is reached. The path should not extend beyond the grid.</p>
<p>The cost of a path is the alternating sum of the numbers written on the cells in a path. That is, let the numbers written on the cells be $ a_1, a_2, \ldots, a_k $ (in the order that it is visited), the cost of the path is $ a_1 - a_2 + a_3 - a_4 + \ldots &#x3D; \sum_{i&#x3D;1}^k a_i \cdot (-1)^{i+1} $ .</p>
<p>Construct a way to place the integers $ 1, 2, \ldots, 2n $ on the grid, such that the minimum cost over all paths from $ (1, 1) $ to $ (2, n) $ is maximized. If there are multiple such grids that result in the maximum value, output any of them.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \leq t \leq 1000 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first and the only line of each test case contains a single integer $ n $ ( $ 2 \leq n \leq 10^5 $ , $ n $ is even) — the number of the columns in the grid.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output $ 2 $ lines, each containing $ n $ integers — the desired grid. If there are multiple solutions, output any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">2</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">11 </span><span class="number">5</span> <span class="number">9</span> <span class="number">1</span> <span class="number">7</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">10</span> <span class="number">2</span> <span class="number">8</span> <span class="number">4</span> <span class="number">12</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>贪心</strong>的思想, 要使得最小代价在所有方案里最大, 那么肯定要让加的数尽可能的大, 而通过观察可以发现:</p>
<ul>
<li>第一行的奇数位比如(1, 1), (1, 3), (1, 5)…. 是一定是加数, 偶数位一定是减数</li>
<li>第二行则刚好相反</li>
<li>(1, 1) 和 (2, n) 分别是起点和终点, 是一定会被加上的</li>
</ul>
<p>所以我们要把最大的两个数放在 (1, 1) 和 (2, n)上, 然后小的数放在减数的位置, 大的数放在加数的位置</p>
<p><strong>贪就要贪到底</strong>, 大体原则已经确定了, 就剩下除了起点和终点怎么放了, 要使得相邻差最大, 肯定要让相邻的数的奇偶性一致, 就比如都要放小的数, n - 1 肯定大于 n - 2, 且相邻数之间, 大的尽可能大, 小的尽可能小, 那我们就得出这样一个构造方案:</p>
<ul>
<li><p>第一行: 1(指位置1) 放最大的奇数, 3放次大的奇数…以此类推</p>
<p>​	2放最小的奇数, 4放次小的奇数…以此类推</p>
</li>
<li><p>第二行: n 放最大的偶数, n - 2 放次大的偶数….以此类推</p>
<p>​	n - 1 放最小的偶数, n - 3 放次小的偶数…以此类推</p>
</li>
</ul>
<p>##代码</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> f[<span class="number">3</span>][N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		f[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">2</span> * n - <span class="number">1</span>, f[<span class="number">2</span>][n] = <span class="number">2</span> * n;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">2</span> * n - <span class="number">3</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//i是减数位, i + 1是加数位</span></span><br><span class="line">			f[<span class="number">1</span>][i] = p;</span><br><span class="line">			p += <span class="number">2</span>;</span><br><span class="line">			f[<span class="number">1</span>][i + <span class="number">1</span>] = q;</span><br><span class="line">			q -= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		p = <span class="number">2</span>, q = <span class="number">2</span> * n - <span class="number">2</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//i是减数位, i-1是加数位</span></span><br><span class="line">			f[<span class="number">2</span>][i] = p;</span><br><span class="line">			p += <span class="number">2</span>;</span><br><span class="line">			f[<span class="number">2</span>][i - <span class="number">1</span>] = q;</span><br><span class="line">			q -= <span class="number">2</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span>; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; f[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1817A%20Almost%20Increasing%20Subsequence/</url>
    <content><![CDATA[<h1 id="CF1817A"><a href="#CF1817A" class="headerlink" title="CF1817A"></a>CF1817A</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定长度为 $n$ 一个序列 $a$ 以及 $q$ 次询问，每次询问给出 $l$ 和 $r$，找出序列 $a$ 在 $[l,r]$ 内最长的几乎递增子序列。</p>
<p>对于几乎递增的定义：如果一个序列中不存在连续的三个数 $x$，$y$，$z$，使得 $x \ge y \ge \ z$，则这个序列是几乎递增的。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>A sequence is almost-increasing if it does not contain three consecutive elements $ x, y, z $ such that $ x\ge y\ge z $ .</p>
<p>You are given an array $ a_1, a_2, \dots, a_n $ and $ q $ queries.</p>
<p>Each query consists of two integers $ 1\le l\le r\le n $ . For each query, find the length of the longest almost-increasing subsequence of the subarray $ a_l, a_{l+1}, \dots, a_r $ .</p>
<p>A subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of input contains two integers, $ n $ and $ q $ ( $ 1 \leq n, q \leq 200,000 $ ) — the length of the array $ a $ and the number of queries.</p>
<p>The second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \leq a_i \leq 10^9 $ ) — the values of the array $ a $ .</p>
<p>Each of the next $ q $ lines contains the description of a query. Each line contains two integers $ l $ and $ r $ ( $ 1 \leq l \leq r \leq n $ ) — the query is about the subarray $ a_l, a_{l+1}, \dots, a_r $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each of the $ q $ queries, print a line containing the length of the longest almost-increasing subsequence of the subarray $ a_l, a_{l+1}, \dots, a_r $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">9 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">4</span> <span class="number">3</span> <span class="number">3</span> <span class="number">5</span> <span class="number">6</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">1</span><br><span class="line">4</span><br><span class="line">2</span><br><span class="line">7</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first query, the subarray is $ a_1, a_2, a_3 &#x3D; [1,2,4] $ . The whole subarray is almost-increasing, so the answer is $ 3 $ .</p>
<p>In the second query, the subarray is $ a_1, a_2, a_3,a_4 &#x3D; [1,2,4,3] $ . The whole subarray is a almost-increasing, because there are no three consecutive elements such that $ x \geq y \geq z $ . So the answer is $ 4 $ .</p>
<p>In the third query, the subarray is $ a_2, a_3, a_4, a_5 &#x3D; [2, 4, 3, 3] $ . The whole subarray is not almost-increasing, because the last three elements satisfy $ 4 \geq 3 \geq 3 $ . An almost-increasing subsequence of length $ 3 $ can be found (for example taking $ a_2,a_3,a_5 &#x3D; [2,4,3] $ ). So the answer is $ 3 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>对于给定的序列a, 如果序列长度为2, 那肯定合法, 如果长度增加为3, 那我们就考虑新进来的那个数 a[3] 是否会与 a[2] 和 a[1] 构成不合法的序列, 如果是的话我们直接将 a[3] 删除即可</p>
<p>对此我们可以使用前缀和思想, s[i] 表示从1到i有几个数会使不合法部分出现, 我们称这些数为<strong>坏数</strong>, 在计算询问[l, r]的答案的时候, 我们只需要把区间长度减去这段区间内的坏数个数即可</p>
<p><strong>注意</strong>: </p>
<ul>
<li>s[l]是否 +1, 是由 a[l - 1] 和 a[l - 2] 决定的, 而 a[l - 1] 和 a[l - 2] 是区间外边的数, 我们不希望 [l, r] 的结果被区间外的数影响, 那我们就要减去<strong>被区间外边的数影响才变成坏数</strong>的数的个数, 所以区间[l, r]上<strong>实际的坏数个数</strong> &#x3D; s[r] - s[l + 1], 其中<strong>s[l + 1]既代表不在区间内的坏数, 也代表被区间外的数影响才变成坏数的数的个数</strong></li>
</ul>
<p>综上, ans &#x3D; (r - l + 1) - (s[r] - s[l + 1]);</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], s[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> n, m;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">if</span> (i &lt; <span class="number">3</span>)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (a[i] &lt;= a[i - <span class="number">1</span>] &amp;&amp; a[i - <span class="number">1</span>] &lt;= a[i - <span class="number">2</span>])</span><br><span class="line">				s[i] = s[i - <span class="number">1</span>] + <span class="number">1</span>;	<span class="comment">//代表坏数, 最终要合法只需把坏数删掉即可</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				s[i] = s[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (m--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> l, r;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line">		<span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; <span class="number">3</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, r - l + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, r - l + <span class="number">1</span> - (s[r] - s[l + <span class="number">1</span>]));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1815A/</url>
    <content><![CDATA[<h1 id="Ian-and-Array-Sorting"><a href="#Ian-and-Array-Sorting" class="headerlink" title="Ian and Array Sorting"></a>Ian and Array Sorting</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>为了感谢 $\textrm{lan}$，$\textrm{Mary}$ 赠送了 $\textrm{lan}$ 一个长度为 $n$ 的序列。为了让他自己看起来聪明，他想要让序列按非递减排序。他可以执行以下操作若干次：</p>
<ul>
<li><p>选择数组中的两个元素 $a_i,a_{i+1}$ ( $1\le i&lt;n$ )。</p>
</li>
<li><p>同时将它们减去 $1$，或者都加上 $1$。</p>
</li>
</ul>
<p>（注意：操作后 $a_i,a_{i+1}$ 可以是负数或 $0$）</p>
<p>作为一个聪明人，你会注意到，有些序列 $\textrm{lan}$ 无法让其非递减排序。因此，你决定编写一个程序来确定是否可以使数组按非递减顺序排列。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>第一行是一个正整数 $t$ ( $1\le t\le 10^4$ )，表示测试数据的数量。</p>
<p>对于每组数据：</p>
<p>第一行是一个正整数 $n$ ( $1\le n\le 3\cdot 10^5$ )，表示序列中有多少元素。</p>
<p>第二行是 $n$ 个正整数 $a_1,a_2,\dots,a_n$ ( $1\le a_i\le 10^9$ )，表示序列 $a$ 的元素。</p>
<p>保证 $n$ 的总和不超过 $3\cdot 10^5$。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>对于每个测试数据，如果该序列在操作后能按非递减顺序排序，输出 <code>YES</code>，否则输出 <code>NO</code>。</p>
<p>你可以打印 <code>YES</code>，<code>yEs</code>，<code>yes</code>，<code>Yes</code>，这些都是可以被接受的。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>To thank Ian, Mary gifted an array $ a $ of length $ n $ to Ian. To make himself look smart, he wants to make the array in non-decreasing order by doing the following finitely many times: he chooses two adjacent elements $ a_i $ and $ a_{i+1} $ ( $ 1\le i\le n-1 $ ), and increases both of them by $ 1 $ or decreases both of them by $ 1 $ . Note that, the elements of the array can become negative.</p>
<p>As a smart person, you notice that, there are some arrays such that Ian cannot make it become non-decreasing order! Therefore, you decide to write a program to determine if it is possible to make the array in non-decreasing order.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \leq t \leq 10^4 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first line of each test case consists of a single integer $ n $ ( $ 2\le n\le 3\cdot10^5 $ ) — the number of elements in the array.</p>
<p>The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1\le a_i\le 10^9 $ ) — the elements of the array $ a $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 3\cdot10^5 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output “YES” if there exists a sequence of operations which make the array non-decreasing, else output “NO”.</p>
<p>You may print each letter in any case (for example, “YES”, “Yes”, “yes”, “yEs” will all be recognized as positive answer).</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">5</span> <span class="number">7</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">4</span> <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br><span class="line"><span class="keyword">NO</span></span><br><span class="line"><span class="keyword">YES</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果一个序列满足非递减, 即 a1 &lt;&#x3D; a2 &lt;&#x3D; a3 &lt;&#x3D; … &lt;&#x3D; an, 那么我们一定可以通过操作使得 a1 &#x3D; a2 &#x3D; a3 &#x3D;…&lt;&#x3D; an, 那我们就看看能不能操作原序列让它变成这样</p>
<p>枚举2到n-1, 我们通过操作 a[i] 和 a[i + 1] 让 a[i] &#x3D; a[i - 1], 就这样一路传递下去, 看看最后 </p>
<p>a[n - 1] &lt;&#x3D; a[n] 是否成立</p>
<p>如果不成立, 但是序列长度为奇数, 我们可以通过对(1, 2), (3, 4) …. 进行减1操作, 最终还是能构成一个非递减序列, 而我们也肯定可以把前 n - 1 个数变成相等的, 让差值由最后一个数来承担, 所以当长度为奇数时, 直接输出 <code>YES</code> 即可</p>
<p>如果不成立, 且序列长度为偶数, 那我们就没办法通过上述操作构造非递减序列, 输出 <code>NO</code></p>
<p><strong>注意</strong>: 差值可能会滚雪球越滚越大, 不仅差值要用 <code>long long</code> 存, 序列里的数也要</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line">ll a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>);</span><br><span class="line">	cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	YES\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll v = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">			a[i] -= v;</span><br><span class="line">			a[i + <span class="number">1</span>] -= v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (a[n - <span class="number">2</span>] &lt;= a[n - <span class="number">1</span>])</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	YES\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	NO\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1818B%20Indivisible/</url>
    <content><![CDATA[<h1 id="CF1818B-Indivisible"><a href="#CF1818B-Indivisible" class="headerlink" title="CF1818B Indivisible"></a>CF1818B Indivisible</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个整数 $n$。</p>
<p>你需要构造一个一个长度为 $n$ 的排列 $A$，使得对于任意一对 $l,r$（$1\le l&lt;r\le n$），都满足 $A_l+A_{l+1}+\dots+A_r$ 不可以被 $r-l+1$ 整除。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入一个 $t(1\le t\le 100)$ 表示数据组数。</p>
<p>每组数据一行一个整数 $n(1\le n\le100)$，即排列的长度。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据，若所求排列不存在，输出 <code>-1 </code>, 否则输出任意一个合法的排列。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>You’re given a positive integer $ n $ .</p>
<p>Find a permutation $ a_1, a_2, \dots, a_n $ such that for any $ 1 \leq l &lt; r \leq n $ , the sum $ a_l + a_{l+1} + \dots + a_r $ is not divisible by $ r-l+1 $ .</p>
<p>A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n&#x3D;3 $ but there is $ 4 $ in the array).</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 100 $ ). Description of the test cases follows.</p>
<p>The first line of each test case contain a single integer $ n $ ( $ 1 \leq n \leq 100 $ ) — the size of the desired permutation.</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, if there is no such permutation print $ -1 $ .</p>
<p>Otherwise, print $ n $ distinct integers $ p_1, p_{2}, \dots, p_n $ ( $ 1 \leq p_i \leq n $ ) — a permutation satisfying the condition described in the statement.</p>
<p>If there are multiple solutions, print any.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1 2</span><br><span class="line"><span class="deletion">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first example, there are no valid pairs of $ l &lt; r $ , meaning that the condition is true for all such pairs.</p>
<p>In the second example, the only valid pair is $ l&#x3D;1 $ and $ r&#x3D;2 $ , for which $ a_1 + a_2 &#x3D; 1+2&#x3D;3 $ is not divisible by $ r-l+1&#x3D;2 $ .</p>
<p>in the third example, for $ l&#x3D;1 $ and $ r&#x3D;3 $ the sum $ a_1+a_2+a_3 $ is always $ 6 $ , which is divisible by $ 3 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当 $n &#x3D; 1$ 时, 输出1</p>
<p>当 $n$ 为非1的奇数时, 整个区间的和是$\frac{(1 + n)\times n}{2}$, 除以 $n$ 剩下 $\frac{1+n}{2}$ , $n+1$ 是偶数, 所以当 $n$ 为非1奇数时, 输出-1</p>
<p>当n为偶数时, 我们构造出的合法的序列要满足两个条件</p>
<ul>
<li><strong>相邻的数奇偶性不能一样, 这样当区间长度为2时不满足条件</strong></li>
<li><strong>三个连续的数不能放一块, 不然肯定可以被3整除</strong></li>
</ul>
<p>在满足以上两种情况的条件下, 我们尝试打表找规律, 打表代码也在代码部分给出</p>
<p>抽出每个输入对应输出的<strong>第一个</strong>合法方案, 尝试找规律</p>
<p>输入:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">6</span><br><span class="line">8</span><br></pre></td></tr></table></figure>

<p>输出:</p>
<figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">//以下为合法结果之1</span><br><span class="line">2<span class="number"> 1 </span>4 3</span><br><span class="line">2<span class="number"> 1 </span>4<span class="number"> 3 </span>6 5</span><br><span class="line">2<span class="number"> 1 </span>4<span class="number"> 3 </span>6<span class="number"> 5 </span>8 7</span><br></pre></td></tr></table></figure>

<p>我们猜测: 当 i 为奇数时, a[i] 为 i + 1, 当 i 为偶数时, a[i] 为 i - 1</p>
<p>我们分以下两种情况讨论</p>
<ul>
<li>当 l 和 r 奇偶性不同时</li>
</ul>
<p>  在区间[l, r]上 $sum &#x3D; \frac{(a[l] + a[r])\times(l+r-1)}{2}$ , 在除以 $(l+r-1)$ 之后剩下 $\frac{a[l]+a[r]}{2}$ </p>
<p>  根据规则 $a[l] + a[r] &#x3D; l + r$ , 明显结果是奇数, 合法</p>
<ul>
<li><p>当 l 和 r 奇偶性相同时</p>
<p>根据规则 $a[l] + a[r] &#x3D; l + r \pm 1$ , 在区间[l, r]上 $sum &#x3D; \frac{(l+r\pm1)\times(l+r-1)}{2}$ , 在除以$(l+r-1)$ 之后剩下 $\frac{l+r\pm1}{2}$ , $l+r$ 是偶数, $\pm1$ 之后变成奇数, 也合法</p>
</li>
</ul>
<p>综上, 这种构造方法是合法的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="打表代码"><a href="#打表代码" class="headerlink" title="打表代码"></a>打表代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> f[<span class="number">10010</span>];</span><br><span class="line"><span class="type">bool</span> st[<span class="number">10010</span>];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="comment">//判断是否合法</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (f[i] % <span class="number">2</span> == f[i + <span class="number">1</span>] % <span class="number">2</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">abs</span>(f[i] - f[i + <span class="number">1</span>]) == <span class="built_in">abs</span>(f[i + <span class="number">1</span>] - f[i + <span class="number">2</span>]) &amp;&amp; <span class="built_in">abs</span>(f[i] - f[i + <span class="number">1</span>]) == <span class="number">1</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归求每一种方案</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (u == n)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">check</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">				cout &lt;&lt; f[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (!st[i])</span><br><span class="line">		&#123;</span><br><span class="line">			f[u] = i;</span><br><span class="line">			st[i] = <span class="literal">true</span>;</span><br><span class="line">			<span class="built_in">fun</span>(u + <span class="number">1</span>);</span><br><span class="line">			st[i] = <span class="literal">false</span>;</span><br><span class="line">			f[u] = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cin &gt;&gt; n;</span><br><span class="line">	<span class="built_in">fun</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; 1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (n % <span class="number">2</span>)</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot; -1\n&quot;</span>);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i % <span class="number">2</span>)</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i + <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i - <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1818A%20Politics/</url>
    <content><![CDATA[<h1 id="CF1818A-Politics"><a href="#CF1818A-Politics" class="headerlink" title="CF1818A Politics"></a>CF1818A Politics</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个有着 $n$ 个成员的辩论俱乐部中（你是其中的第 $1$ 个成员），有 $k$ 个辩题即将被按顺序辩论。在每次辩论中，俱乐部的成员们会表达他们同意或者不同意这个辩题。我们假设有 $Y$ 个成员同意， $N$ 个成员不同意。在每次辩论之后，成员们会按照以下的规则退出俱乐部：</p>
<ul>
<li>如果同意的成员多于不同意的成员（ $Y &gt; N$ ），那么所有不同意的成员会退出俱乐部；</li>
<li>如果不同意的成员多于同意的成员（ $Y &lt; N$ ），那么所有同意的成员会退出俱乐部；</li>
<li>如果平局（ $Y &#x3D; N$ ），那么所有成员都会退出俱乐部。</li>
</ul>
<p>作为俱乐部的部长，你的目标是让自己待在俱乐部里，并且使辩论之后俱乐部里剩余的成员的数量最大化。在辩论开始之前，你已经得知了每一位成员对于各个辩题的意见，并且你可以在辩论开始之前开除任意数量的成员（不包括你自己）。</p>
<p>你需要求出辩论之后俱乐部里最多能剩下多少人（包括你自己）。你不需要输出开除的方案。请确保最后你自己还在俱乐部里。</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>每个测试点包含多组数据。输入数据的第一行包含数据组数 $t$ ( $1 \le t \le 100$ )。第二行及以下是测试数据。</p>
<p>每组测试数据的第一行包含两个正整数 $n$ 和 $k$ ( $1 \le n,k \le 100$ )，分别表示俱乐部内成员的个数和辩题的个数。</p>
<p>接下来的 $n$ 行中，第 $i$ 行包含一个长度为 $k$ 的字符串 $t_i$ 。字符串 $t_i$ 中的第 $j$ 个字符（ $+$  或 $-$ ）描述了第 $i$ 位成员对第 $j$ 个辩题的意见（如果这时候他&#x2F;她还在俱乐部中）。“ $+$ ”代表同意，而“ $-$ ”代表不同意。</p>
<p>输入保证各组数据的 $n \sdot k$ 之和不超过 $5 \sdot 10^4$ 。</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>对于每组数据，输出辩论之后俱乐部里最多能剩下的人数。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>In a debate club with $ n $ members, including yourself (member $ 1 $ ), there are $ k $ opinions to be discussed in sequence. During each discussion, members express their agreement or disagreement with the opinion. Let’s define $ Y $ as the number of members who agree and $ N $ as the number of members who disagree. After each discussion, members leave the club based on the following criteria:</p>
<ul>
<li>If more members agree than disagree ( $ Y &gt; N $ ), all members who disagreed leave the club.</li>
<li>If more members disagree than agree ( $ Y &lt; N $ ), all members who agreed leave the club.</li>
<li>If there is a tie ( $ Y &#x3D; N $ ), all members leave the club.</li>
</ul>
<p>As the club president, your goal is to stay in the club and maximize the number of members remaining after the meeting. You have access to each member’s stance on all $ k $ opinions before the meeting starts, and you can expel any number of members (excluding yourself) before the meeting begins.</p>
<p>Determine the maximum number of members, including yourself, who can remain in the club after the meeting. You don’t need to provide the specific expulsion strategy but only the maximum number of members that can stay. Ensure that you remain in the club after the meeting as well.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 1000 $ ). Description of the test cases follows.</p>
<p>The first line of each test case contains two positive integers $ n $ and $ k $ ( $ 1 \le n, k \le 100 $ ) — the number of members and the number of discussions.</p>
<p>The $ i $ -th of the following $ n $ lines contains a string $ t_i $ of length $ k $ . The $ j $ -th character in the string $ t_i $ indicates whether the $ i $ -th member agrees or disagrees with the $ j $ -th opinion if they are present during that discussion. A “+” symbol means the member agrees, while a “-“ symbol means the member disagrees.</p>
<p>It is guaranteed that the sum of $ n \cdot k $ over all test cases does not exceed $ 5 \cdot 10^4 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the maximum number of members, including yourself, who can remain in the club after the meeting.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight asciidoc"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line"><span class="section">2 2</span></span><br><span class="line"><span class="section">++</span></span><br><span class="line">+-</span><br><span class="line"><span class="section">1 3</span></span><br><span class="line"><span class="section">+-+</span></span><br><span class="line">4 1</span><br><span class="line">+</span><br><span class="line"><span class="bullet">-</span></span><br><span class="line"><span class="bullet"></span><span class="bullet">-</span></span><br><span class="line"><span class="bullet"></span>+</span><br><span class="line"><span class="section">5 4</span></span><br><span class="line"><span class="section">++++</span></span><br><span class="line"><span class="section">+--+</span></span><br><span class="line"><span class="section">++-+</span></span><br><span class="line"><span class="section">+-++</span></span><br><span class="line"><span class="section">++++</span></span><br><span class="line"><span class="section">4 2</span></span><br><span class="line"><span class="section">++</span></span><br><span class="line"><span class="section">--</span></span><br><span class="line"><span class="section">--</span></span><br><span class="line">-+</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>重点在你要让自己留下来, 那么只有意见跟你一样的才可以留下来, 而意见和你不一样的你可以在辩论开始前开除他们,问题就转化为求有多少个人意见和自己一致, 复杂度是 $O(n)$</p>
<p>第一行是自己的意见</p>
<p>是道思维题, 别想的很复杂</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">		string s[<span class="number">110</span>];</span><br><span class="line">		<span class="type">int</span> ans = n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; s[i];</span><br><span class="line">			<span class="keyword">if</span> (s[i] != s[<span class="number">0</span>])</span><br><span class="line">				ans--;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1821B/</url>
    <content><![CDATA[<h1 id="Sort-the-Subarray"><a href="#Sort-the-Subarray" class="headerlink" title="Sort the Subarray"></a>Sort the Subarray</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有一个序列 $a$，cff 排序了其中一段子序列 $[l,r]$，得到了另一个新的序列。给出这两个序列，求 cff 排序的那一段子序列的左右端点 $l,r$。输出最长的可能的子序列。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Monocarp had an array $ a $ consisting of $ n $ integers. He has decided to choose two integers $ l $ and $ r $ such that $ 1 \le l \le r \le n $ , and then sort the subarray $ a[l..r] $ (the subarray $ a[l..r] $ is the part of the array $ a $ containing the elements $ a_l, a_{l+1}, a_{l+2}, \dots, a_{r-1}, a_r $ ) in non-descending order. After sorting the subarray, Monocarp has obtained a new array, which we denote as $ a’ $ .</p>
<p>For example, if $ a &#x3D; [6, 7, 3, 4, 4, 6, 5] $ , and Monocarp has chosen $ l &#x3D; 2, r &#x3D; 5 $ , then $ a’ &#x3D; [6, 3, 4, 4, 7, 6, 5] $ .</p>
<p>You are given the arrays $ a $ and $ a’ $ . Find the integers $ l $ and $ r $ that Monocarp could have chosen. If there are multiple pairs of values $ (l, r) $ , find the one which corresponds to the longest subarray.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>Each test case consists of three lines:</p>
<ul>
<li>the first line contains one integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ );</li>
<li>the second line contains $ n $ integers $ a_1, a_2, \dots, a_n $ ( $ 1 \le a_i \le n $ );</li>
<li>the third line contains $ n $ integers $ a’_1, a’_2, \dots, a’_n $ ( $ 1 \le a’_i \le n $ ).</li>
</ul>
<p>Additional constraints on the input:</p>
<ul>
<li>the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^5 $ ;</li>
<li>it is possible to obtain the array $ a’ $ by sorting one subarray of $ a $ ;</li>
<li>$ a’ \ne a $ (there exists at least one position in which these two arrays are different).</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print two integers — the values of $ l $ and $ r $ ( $ 1 \le l \le r \le n $ ). If there are multiple answers, print the values that correspond to the longest subarray. If there are still multiple answers, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">7</span> <span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">3</span> <span class="number">4</span> <span class="number">4</span> <span class="number">7</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span> <span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为 $a’$ 和 $a$, 至少有一处不一样, 而不同肯定是由 sort 造成的, 所以这个地方一定在 sort 的区间内, 我们找到这个点, 分别向左向右扩展, 找到最大的非递减区间即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; b[i];</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> c = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != b[i]) </span><br><span class="line">			&#123;</span><br><span class="line">				c = i; <span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> l = c, r = c;</span><br><span class="line">		<span class="keyword">while</span>(l &gt; <span class="number">0</span> || r &lt;= n)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> l1 = l, r1 = r;</span><br><span class="line">			<span class="keyword">if</span>(l &gt; <span class="number">1</span> &amp;&amp; b[l - <span class="number">1</span>] &lt;= b[l]) l--;</span><br><span class="line">			<span class="keyword">if</span>(r &lt; n &amp;&amp; b[r + <span class="number">1</span>] &gt;= b[r]) r++;</span><br><span class="line">			<span class="keyword">if</span>(l1 == l &amp;&amp; r1 == r) <span class="keyword">break</span>;	<span class="comment">//如果两个都没动, 就说明无法扩展, 就说明找到答案了</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; l &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1820B/</url>
    <content><![CDATA[<h1 id="JoJo’s-Incredible-Adventures"><a href="#JoJo’s-Incredible-Adventures" class="headerlink" title="JoJo’s Incredible Adventures"></a>JoJo’s Incredible Adventures</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个长度为 $n$ 的二进制字符串 $s$，构建一个 $n \times n$ 的方格表。首行写下原始字符串 $s$，次行右移一个字符的循环移位字符串 $s$，第三行右移两个字符的循环移位字符串 $s$，以此类推。因此，第 $k$ 行包含一个从 $s$ 右移 $k$ 个字符的循环移位字符串。行从上到下编号 $0$ 至 $n-1$。</p>
<p>在生成的表中，需要找到只由数字 $1$ 构成的矩形并计算其面积，返回最大的面积。</p>
<p>注意：字符串 $s$ 向右循环移动 $k$ 位是指将其最后 $k$ 个字符移动到前面，即字符串 $s_{n-k+1} \cdots s_n ; s_1 \cdots s_{n-k}$。</p>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行的正整数 $t$ ($1\leq t\leq 2\times10^4$) 是测试用例的数量。 对于每个测试用例，只有一行，是一个只由零和一组成的二进制字符串。</p>
<p>保证所有测试用例中字符总数之和不超过 $2\times 10^5$。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每个测试用例，输出一个整数：只由数字 $1$ 构成的矩形的最大面积。如果不存在这样的矩形，则输出 $0$。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Did you think there was going to be a JoJo legend here? But no, that was me, Dio!</p>
<p>Given a binary string $ s $ of length $ n $ , consisting of characters 0 and 1. Let’s build a square table of size $ n \times n $ , consisting of 0 and 1 characters as follows.</p>
<p>In the first row of the table write the original string $ s $ . In the second row of the table write cyclic shift of the string $ s $ by one to the right. In the third row of the table, write the cyclic shift of line $ s $ by two to the right. And so on. Thus, the row with number $ k $ will contain a cyclic shift of string $ s $ by $ k $ to the right. The rows are numbered from $ 0 $ to $ n - 1 $ top-to-bottom.</p>
<p>In the resulting table we need to find the rectangle consisting only of ones that has the largest area.</p>
<p>We call a rectangle the set of all cells $ (i, j) $ in the table, such that $ x_1 \le i \le x_2 $ and $ y_1 \le j \le y_2 $ for some integers $ 0 \le x_1 \le x_2 &lt; n $ and $ 0 \le y_1 \le y_2 &lt; n $ .</p>
<p>Recall that the cyclic shift of string $ s $ by $ k $ to the right is the string $ s_{n-k+1} \ldots s_n s_1 s_2 \ldots s_{n-k} $ . For example, the cyclic shift of the string “01011” by $ 0 $ to the right is the string itself “01011”, its cyclic shift by $ 3 $ to the right is the string “01101”.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test consists of multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 2 \cdot 10^4 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first and the only line of each test case contains a single binary string $ s $ ( $ 1 \le \lvert s \rvert \le 2 \cdot 10^5 $ ), consisting of characters 0 and 1.</p>
<p>It is guaranteed that the sum of string lengths $ |s| $ over all test cases does not exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output a single integer — the maximum area of a rectangle consisting only of ones. If there is no such rectangle, output $ 0 $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">101</span><br><span class="line">011110</span><br><span class="line">101010</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">6</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, there is a table $ 1 \times 1 $ consisting of a single character 0, so there are no rectangles consisting of ones, and the answer is $ 0 $ .</p>
<p>In the second test case, there is a table $ 1 \times 1 $ , consisting of a single character 1, so the answer is $ 1 $ .</p>
<p>In the third test case, there is a table:</p>
<p> 101110011In the fourth test case, there is a table:</p>
<p> 011110001111100111110011111001111100In the fifth test case, there is a table:</p>
<p> 101010010101101010010101101010010101Rectangles with maximum area are shown in bold.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul>
<li>如果 s 全为1, 最大矩形面积就是 s.size() * s.size()</li>
<li>如果不是全为1, 我们找出连续是1的最长段, 长度记为 len, 此时这个矩形的周长 &#x3D; (len + 1) * 2, 下一行右移一次后, 矩形的长 - 1, 宽 + 1, 由此类推: <strong>矩形的周长是不变的</strong>, $x + y &#x3D; k$, 要求 $x\times y$ 的最大值, 即求 $f(x) &#x3D; x\times (k - x)$ 的最大值, 当 $x &#x3D; \frac{k}{2}$ 时能取得最大值, 也就是说要让 $x$ 和 $y$ 尽可能接近 $\frac{k}{2}$</li>
</ul>
<p>对于第二种情况, 开头的1和结尾的1是可以通过右移连接起来的, 所以连续是1的最长段<strong>可能是在右移之后出现</strong>, 我们怎么解决呢? 可以把s和s拼起来, 反正右移之后会连接起来, 那我们刚开始就把 s 和 s 拼起来是没关系的, 而且拼起来之后才不用枚举每一行去找最长的连续是1的段, 避免了一个 $O(n^{2})$ 的操作</p>
<p>又因为如果s全为1, 那么拼起来之后1出现的次数就翻倍了, 我们要在这种情况下让 maxlen 除以2</p>
<p>那拼起来之后不会对第二种情况有影响吗? 是不会的, 因为会有0在中间隔开, 就算我们把开头结尾拼起来, 那也只是在复现本来就会出现的情况, 如果最长的连续是1的段不是这种情况, 那么就会被0隔开, 不会翻倍的</p>
<p>n &#x3D; $2\times 10^{5}$ , 那么答案最大是 n * n, 会爆int, 要用 <code>unsigned long long</code> 存</p>
<p>考虑最长连续出现1的段, 用到了<strong>贪心</strong>的思想</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ULL;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		string s;</span><br><span class="line">		cin &gt;&gt; s;</span><br><span class="line">		s += s;</span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		ULL maxlen = <span class="number">0</span>, curlen = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				maxlen = <span class="built_in">max</span>(curlen, maxlen);</span><br><span class="line">				curlen = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				curlen++;</span><br><span class="line">		&#125;</span><br><span class="line">		maxlen = <span class="built_in">max</span>(curlen, maxlen);</span><br><span class="line">		<span class="keyword">if</span> (!flag)</span><br><span class="line">		&#123;</span><br><span class="line">			maxlen /= <span class="number">2</span>;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	%lld\n&quot;</span>, maxlen * maxlen);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			maxlen++;</span><br><span class="line">			ULL x = maxlen / <span class="number">2</span>, y = <span class="built_in">ceil</span>(<span class="built_in">double</span>(maxlen) / <span class="number">2</span>);	<span class="comment">//x向下取整, y向上取整, 尽可能靠近 maxlen / 2</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;	%lld\n&quot;</span>, x * y);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1821C/</url>
    <content><![CDATA[<h1 id="Tear-It-Apart"><a href="#Tear-It-Apart" class="headerlink" title="Tear It Apart"></a>Tear It Apart</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>现有一个由小写字母组成的字符串，你将对这个字符串进行操作。每次操作你可以选择任意多个（可以只选一个）两两在字符串中不相邻的字母，把它们从字符串中删除。求至少进行多少次操作，字符串里的所有字母相同。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a string $ s $ , consisting of lowercase Latin letters.</p>
<p>In one operation, you can select several (one or more) positions in it such that no two selected positions are adjacent to each other. Then you remove the letters on the selected positions from the string. The resulting parts are concatenated without changing their order.</p>
<p>What is the smallest number of operations required to make all the letters in $ s $ the same?</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of testcases.</p>
<p>The only line of each testcase contains a string $ s $ , consisting of lowercase Latin letters. Its length is from $ 1 $ to $ 2 \cdot 10^5 $ .</p>
<p>The total length of the strings over all testcases doesn’t exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each testcase, print a single integer — the smallest number of operations required to make all the letters in the given string $ s $ the same.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line">abacaba</span><br><span class="line">codeforces</span><br><span class="line">oooooooo</span><br><span class="line">abc<span class="keyword">def</span></span><br><span class="line"><span class="title function_">mewheniseearulhiiarul</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first testcase, you can select positions $ 2, 4 $ and $ 6 $ and remove the corresponding letters ‘b’, ‘c’ and ‘b’.</p>
<p>In the third testcase, the letters in the string are already the same, so you don’t have to make any operations.</p>
<p>In the fourth testcase, one of the possible solutions in $ 2 $ operations is the following. You can select positions $ 1, 4, 6 $ first. The string becomes “bce”. Then select positions $ 1 $ and $ 3 $ . The string becomes “c”. All letters in it are the same, since it’s just one letter.</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>从 a 到 z 枚举最终剩下的字母 res, 视 res 为分界点, 把字符串 s 分成若干段, 对于一段字符串来说, 我们每次最多可以删去这一段一半个字符串, 所以对于一段长度为 len 的字符串, 要全部删完需要的操作步数是 $\log_{2}{len} + 1$ </p>
<p>在确定保留字母 res 的情况下, 我们需要的操作步数是由被分割出来的最长的段决定的, 所以我们只需要找出最长的段的长度即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> str[N];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;str);</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">char</span> i = <span class="string">&#x27;a&#x27;</span>; i &lt;= <span class="string">&#x27;z&#x27;</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> maxl = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; str[j]; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (str[j] != i)</span><br><span class="line">					len++;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					maxl = <span class="built_in">max</span>(len, maxl);</span><br><span class="line">					len = <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			maxl = <span class="built_in">max</span>(len, maxl);	<span class="comment">//处理尾部, 像这种被 不同 触发更新的都要处理尾部</span></span><br><span class="line">			<span class="comment">//如果没有段需要被删除</span></span><br><span class="line">			<span class="keyword">if</span>(!maxl) </span><br><span class="line">			&#123;</span><br><span class="line">				ans = <span class="number">0</span>;	<span class="comment">//log0不合法 要特判一下</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ans = <span class="built_in">min</span>(ans, <span class="built_in">int</span>(<span class="built_in">log2</span>(maxl) + <span class="number">1</span>));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;	%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1823B/</url>
    <content><![CDATA[<h1 id="Sort-with-Step"><a href="#Sort-with-Step" class="headerlink" title="Sort with Step"></a>Sort with Step</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定一个 $1$ 到 $n$ 的排列 $p$ 和一个正整数 $k$。</p>
<p>你可以对 $p$ 进行若干次操作，每次操作交换 $p_i$ 和 $p_j$，其中 $|i-j|&#x3D;k$。你的目标是使得 $p$ 变为升序。</p>
<p>除此之外，在开始你的操作之前，你还可以<strong>预先交换</strong>任意两个 $p_i$ 和 $p_j$ 一次。</p>
<p>你的任务是判断：</p>
<ol>
<li>能否在不用预先交换的情况下，使得 $p$ 变为升序；</li>
<li>如果不能，能否在预先交换一次的情况下，使得 $p$ 变为升序。</li>
</ol>
<h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>本题有<strong>多组数据</strong>。第一行输入数据组数 $t$（$1\le t\le10^4$）。</p>
<p>对于每组数据，第一行输入 $n$ 和 $k$，第二行输入 $n$ 个整数，其中第 $i$ 个整数表示 $p_i$。</p>
<h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>对于每组数据：</p>
<ul>
<li>如果满足条件 1 输出一行 <code>0</code>；</li>
<li>如果不满足条件 1 但满足条件 2 输出一行 <code>1</code>；</li>
<li>如果条件 1, 2 都不满足输出一行 <code>-1</code>。</li>
</ul>
<h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>$1\le t\le10^4$，$2\le n\le2\times10^5$，$1\le k\le n-1$，$1\le p_i\le n$。</p>
<p>每组数据的 $n$ 的总和 $\sum n\le2\times10^5$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Let’s define a permutation of length $ n $ as an array $ p $ of length $ n $ , which contains every number from $ 1 $ to $ n $ exactly once.</p>
<p>You are given a permutation $ p_1, p_2, \dots, p_n $ and a number $ k $ . You need to sort this permutation in the ascending order. In order to do it, you can repeat the following operation any number of times (possibly, zero):</p>
<ul>
<li>pick two elements of the permutation $ p_i $ and $ p_j $ such that $ |i - j| &#x3D; k $ , and swap them.</li>
</ul>
<p>Unfortunately, some permutations can’t be sorted with some fixed numbers $ k $ . For example, it’s impossible to sort $ [2, 4, 3, 1] $ with $ k &#x3D; 2 $ .</p>
<p>That’s why, before starting the sorting, you can make at most one preliminary exchange:</p>
<ul>
<li>choose any pair $ p_i $ and $ p_j $ and swap them.</li>
</ul>
<p>Your task is to:</p>
<ol>
<li>check whether is it possible to sort the permutation without any preliminary exchanges,</li>
<li>if it’s not, check, whether is it possible to sort the permutation using exactly one preliminary exchange.</li>
</ol>
<p>For example, if $ k &#x3D; 2 $ and permutation is $ [2, 4, 3, 1] $ , then you can make a preliminary exchange of $ p_1 $ and $ p_4 $ , which will produce permutation $ [1, 4, 3, 2] $ , which is possible to sort with given $ k $ .</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers $ n $ and $ k $ ( $ 2 \le n \le 2 \cdot 10^5 $ ; $ 1 \le k \le n - 1 $ ) — length of the permutation, and a distance between elements that can be swapped.</p>
<p>The second line of each test case contains $ n $ integers $ p_1, p_2, \dots, p_n $ ( $ 1 \le p_i \le n $ ) — elements of the permutation $ p $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10 ^ 5 $ .</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case print</p>
<ul>
<li>0, if it is possible to sort the permutation without preliminary exchange;</li>
<li>1, if it is possible to sort the permutation with one preliminary exchange, but not possible without preliminary exchange;</li>
<li>-1, if it is not possible to sort the permutation with at most one preliminary exchange.</li>
</ul>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">4</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span> <span class="number">9</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">10</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span> <span class="number">9</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">10</span> <span class="number">2</span> <span class="number">3</span> <span class="number">7</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">6</span> <span class="number">9</span> <span class="number">1</span> <span class="number">8</span> <span class="number">5</span> <span class="number">10</span> <span class="number">3</span> <span class="number">2</span> <span class="number">7</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line"><span class="deletion">-1</span></span><br></pre></td></tr></table></figure>

<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p>In the first test case, there is no need in preliminary exchange, as it is possible to swap $ (p_1, p_2) $ and then $ (p_2, p_3) $ .</p>
<p>In the second test case, there is no need in preliminary exchange, as it is possible to swap $ (p_1, p_3) $ and then $ (p_2, p_4) $ .</p>
<p>In the third test case, you need to apply preliminary exchange to $ (p_2, p_3) $ . After that the permutation becomes $ [3, 4, 1, 2] $ and can be sorted with $ k &#x3D; 2 $ .</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以开一次挂, 交换任意的两个数</p>
<p>序列a的元素只有1~n, 且没有重复, 那么成功排序后值为 i 的元素位置也是 i (下标从1开始), 也即对于 a[i] 而言, i是起点位置, a[i] 是目的位置, 如果 <strong>a[i] - i 是 k 的整数倍</strong>, 那么他就肯定可以通过和<strong>距离为 k 的数交换最终到达目的位置</strong>, 称为合法数</p>
<ul>
<li><p>如果所有的数都是合法数, 那么我们不需要开挂就能sort成功</p>
</li>
<li><p>如果不合法数 $\ge 3$ , 那么肯定没办法sort, 输出-1</p>
</li>
<li><p>如果有两个不合法数, 我们交换这两个数看是否能合法</p>
</li>
<li><p>如果有一个不合法数, 我们遍历序列a, 看有没有哪个数能跟他换</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="type">int</span> b[N];	<span class="comment">//记录哪些不合法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, k;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">		<span class="type">int</span> un = <span class="number">0</span>;		<span class="comment">//不合法的人数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(a[i] - i) % k)</span><br><span class="line">			&#123;</span><br><span class="line">				b[++un] = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (un &gt;= <span class="number">3</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  -1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(un == <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> sta1 = b[<span class="number">1</span>], ed1 = a[b[<span class="number">1</span>]];</span><br><span class="line">			<span class="type">int</span> sta2 = b[<span class="number">2</span>], ed2 = a[b[<span class="number">2</span>]];</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">abs</span>(ed1 - sta2) % k == <span class="number">0</span> &amp;&amp; <span class="built_in">abs</span>(ed2 - sta1) % k == <span class="number">0</span>)</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;  1\n&quot;</span>);</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;  -1\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (un == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;  0\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i == n + <span class="number">1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;  -1\n&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="type">int</span> sta1 = b[<span class="number">1</span>], ed1 = a[b[<span class="number">1</span>]];</span><br><span class="line">				<span class="type">int</span> sta2 = i, ed2 = a[i];</span><br><span class="line">				<span class="keyword">if</span> (<span class="built_in">abs</span>(ed2 - ed1) % k == <span class="number">0</span>)	<span class="comment">//是化简之后的结果</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;  1\n&quot;</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1824A/</url>
    <content><![CDATA[<h1 id="CF1824A"><a href="#CF1824A" class="headerlink" title="CF1824A"></a>CF1824A</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有n个观众, m个座位(编号从1开始), 观众分为三种</p>
<ul>
<li>坐到最左边的人的左边, 如果座位1有人坐了, 就离场, 如果座位全空, 就坐到座位m</li>
<li>坐到最右边的人的右边, 如果座位m有人坐了, 就离场, 如果座位全空, 就坐到座位1</li>
<li>坐到指定位置x, 如果座位x有人坐了, 就离场</li>
</ul>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>t个样例, $t \le 10^{4}$ </p>
<p>n $\le 10^{5}$ 和 m $\le 10 ^{5}$ </p>
<p>然后n个x, x $&#x3D; -1$ 时表示是观众1, x $&#x3D;-2$ 表示是观众2, x $\ge 0$ 表示要坐到位置x上, 即观众3</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>每两个观众3之间的留下的空位可以用观众1和2补上, 我们可以用前缀和求出: 座位1到m有几个观众三, 然后就能求出有几个空位</p>
<p>我们也必须考虑 <strong>只采用观众1和观众3</strong> 还有 <strong>只采用观众2和观众3</strong> 的情况, 比如以下这个例子:</p>
<p>当 <code>m = 8</code> 然后观众是 <code>-1 -1 -1 3  -1 -2</code> 的时候, 舍弃观众2让观众1从m往左填是最优</p>
<p>综上我们要计算只采用观众1和观众3还有只采用观众2和观众3的结果, 然后再枚举每个观众三作为分水岭, 分别向左向右填的结果, 所有结果取max即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="type">int</span> bk[N] = &#123; <span class="number">0</span> &#125;;	<span class="comment">//桶</span></span><br><span class="line">		<span class="type">int</span> k1, k2, k3;</span><br><span class="line">		k1 = k2 = k3 = <span class="number">0</span>;	<span class="comment">//三种观众的个数</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> x;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">			<span class="keyword">if</span> (x &gt; <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (!bk[x])</span><br><span class="line">				&#123;</span><br><span class="line">					k3++;</span><br><span class="line">					bk[x] = <span class="number">1</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">-1</span>)</span><br><span class="line">				k1++;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				k2++;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">		<span class="type">int</span> ans1 = <span class="built_in">min</span>(m, k1 + k3);	<span class="comment">//只让观众1和3入场</span></span><br><span class="line">		<span class="type">int</span> ans2 = <span class="built_in">min</span>(m, k2 + k3);	<span class="comment">//只让观众2和3入场</span></span><br><span class="line">		ret = <span class="built_in">max</span>(ans2, ans1);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			bk[i] += bk[i - <span class="number">1</span>];	<span class="comment">//前缀和 表示从1到i有几个观众三预定好了座位</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//枚举每个点 以此为分水岭向左右延伸</span></span><br><span class="line">		<span class="type">int</span> ans3 = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//如果这个位置有观众三</span></span><br><span class="line">			<span class="keyword">if</span> (bk[i] &gt; bk[i - <span class="number">1</span>])</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="type">int</span> l = <span class="built_in">min</span>(i - <span class="number">1</span> - bk[i - <span class="number">1</span>], k1), r = <span class="built_in">min</span>(m - i - (bk[m] - bk[i]), k2);</span><br><span class="line">				ans3 = <span class="built_in">max</span>(ans3, l + r + k3);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">max</span>(ret, ans3);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, ret);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1825A/</url>
    <content><![CDATA[<h1 id="CF1825A"><a href="#CF1825A" class="headerlink" title="CF1825A"></a>CF1825A</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个回文字符串，找出里边长度最大的非回文字符串子串并输出长度，如果没有则输出 $-1$ </p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>t $(1 \le t \le 50)$ 个测试样例，每个样例长度 $\le 1000$ </p>
<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>每行输出最长非回文字符串子串长度，如果没有就输出 $-1$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>观察得出如果有答案，那么最长子串一定是以 $s[0]$ 开头的，所以我们只需要从后往前遍历子串结尾，判断是否是回文串即可</p>
<p><strong>注意</strong> ：千万不可以凭借开头和结尾不同去找子串，虽然这样一定是非回文串，但不能保证最长，比如 <code>aabbaa</code> 这个样例，如果按开头结尾不同去找，输出答案是 $4$ ，即 <code>aabb</code> ，但是正确答案是 $5$ ，即 <code>aabba</code> </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">char</span> p[], <span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> l = <span class="number">0</span>, r = end;</span><br><span class="line">	<span class="keyword">while</span> (l &lt; r)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p[l] != p[r])</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		l++, r--;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> s[<span class="number">50</span>];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> j = <span class="built_in">strlen</span>(s) - <span class="number">1</span>; j &gt; <span class="number">0</span>; j --)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!<span class="built_in">check</span>(s, j))</span><br><span class="line">			&#123;</span><br><span class="line">				ans = j + <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1825B/</url>
    <content><![CDATA[<h1 id="CF1825B"><a href="#CF1825B" class="headerlink" title="CF1825B"></a>CF1825B</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给我们 $n \times m$ 个数, 让我们放到一个 $n \times m$ 的矩阵中, 从 $(1,1)$ 到 $(i,j)$ 范围内的最大值和最小值的差值记为 $v_{i, j}$ , 问我们如何构造能够使得 $\sum_{i &#x3D; 1}^{n} \sum_{j &#x3D; 1}^{m} v_{i, j}$ 最大, 并输出这个最大值 </p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>t $(t \le 200)$ 个测试案例, 随后 $n \times m$ 个数 $(2\le n, m \le 100)$ , $-10^{5} \le 每个数 \le 10^{5}$ </p>
<p><strong>注意</strong>: $200\times 100 \times 100 \times 2 \times 10^{5}$ 会爆int, 要用long long去存答案</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$ v &#x3D; max(a_{1,1} 到 a_{i, j}) - min(a_{1,1} 到 a_{i, j})$  可以发现我们可以把最大值放在 $(1,1)$ , 两个最小值放在 $(1,2)$ 和 $(2,1)$ , 这样不管 $i$ 和 $j$ 是多少, 我们都能保证取到的 $v$ 是最大的</p>
<p>同理, 把最大值放在 $(1, 1)$ 然后最小值放在 $(1,2)$ 和 $(2,1)$ 也能做到这样</p>
<p>我们两种情况都计算出来取最大值即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>, M = <span class="number">1000</span>;</span><br><span class="line"><span class="type">int</span> val[N], mar[M][M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, m;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">		<span class="keyword">if</span> (n &gt; m) <span class="built_in">swap</span>(n, m);	<span class="comment">//方便处理 最小值放在左上角时 长边放最大值 短边放次大值 相反同理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;val[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(val + <span class="number">1</span>, val + n * m + <span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//最大值在左上角</span></span><br><span class="line">		ll ans1 = (n - <span class="number">1</span>) * (val[n * m] - val[<span class="number">2</span>]) + (m - <span class="number">1</span>) * (val[n * m] - val[<span class="number">1</span>]) + </span><br><span class="line">			(n - <span class="number">1</span>) * (m - <span class="number">1</span>) * (val[n * m] - val[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//最小值在左上角</span></span><br><span class="line">		ll ans2 = (n - <span class="number">1</span>) * (val[n * m - <span class="number">1</span>] - val[<span class="number">1</span>]) + (m - <span class="number">1</span>) * (val[n * m] - val[<span class="number">1</span>]) +</span><br><span class="line">			(n - <span class="number">1</span>) * (m - <span class="number">1</span>) * (val[n * m] - val[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %lld\n&quot;</span>, <span class="built_in">max</span>(ans1, ans2));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1826A/</url>
    <content><![CDATA[<h1 id="CF1826A"><a href="#CF1826A" class="headerlink" title="CF1826A"></a>CF1826A</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>有n个人, 每个人可能是骗子, 会说谎话, 也可能不是, 第i个人说骗子个数 $\ge l_{i}$ , 对于这n个人如果有矛盾, 输出-1, 如果有可能发生, 输出可能的骗子个数, 如果有多个答案输出任意一个</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>t $\le 1000$ , n $\le 100$ , $0 \le l_{i} \le1000$ </p>
<p>t个样例, n个数, 每个数代表n个人说至少有几个骗子</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>直接枚举骗子个数i, 遍历数组, 如果骗子个数刚好等于i, 那么这种情况就符合, 输出i, 如果都不符合就输出-1</p>
<p>直接枚举就可以解决了, $t \le 1000$ , $n \le 100$ , 复杂度最多就是 $t \times n^{2}$ 是1e7, 可以过</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="type">int</span> a[<span class="number">100</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//枚举骗子个数</span></span><br><span class="line">		<span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> actual = <span class="number">0</span>;</span><br><span class="line">			<span class="comment">//不符合条件的就是骗子</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (i &lt; a[j])</span><br><span class="line">					actual++;</span><br><span class="line">			&#125;</span><br><span class="line">         <span class="comment">//刚好相等才是正确答案</span></span><br><span class="line">			<span class="keyword">if</span> (actual == i)</span><br><span class="line">			&#123;</span><br><span class="line">				flag = <span class="literal">true</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, actual);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!flag) <span class="built_in">printf</span>(<span class="string">&quot; -1\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1826B/</url>
    <content><![CDATA[<h1 id="CF1826B"><a href="#CF1826B" class="headerlink" title="CF1826B"></a>CF1826B</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组a, 找到最大的x使得a中所有数mod x之后, a能变成一个回文数组</p>
<p>输出你找到的最大的x, 如果x可以无限大, 输出-1</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>t $\le 10^{5}$,  n $\le 10^{5}$, $0\le$ a[i] $\le 10^{9}$ </p>
<p>t个样例, 每个样例n个数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><code>a[1] % x = q[1]</code> 可以写为 <code>a[1] = n1 * x + q[1]</code>, 要满足<code>q[1] = q[n]</code>, 则 <code>a[n] = n2 * x + q[1]</code></p>
<p>就有 <code>abs (a[1] - a[n]) = abs(n1 - n2) * x</code>, 就有 <code>(a[1] - a[n]) % x == 0</code></p>
<p>以此类推每一对的差值 mod x 都等于0, 那就是每一对的差值都是 x 的倍数, 那我们找出所有差值的最大公因数即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="comment">//最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> b ? <span class="built_in">gcd</span>(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="type">int</span> a[N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			a[i] = <span class="built_in">abs</span>(a[i] - a[n - <span class="number">1</span> - i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;	<span class="comment">//碰见x可以无限大的情况会输出0 不用担心</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = <span class="built_in">gcd</span>(ans, a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1826D/</url>
    <content><![CDATA[<h1 id="CF1826D"><a href="#CF1826D" class="headerlink" title="CF1826D"></a>CF1826D</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>选定区间 [l, r] 使得 $v&#x3D;b_{i1}+b_{i2}+b_{i3}-(r-l)$ 最大, 其中三个b是区间内最大的三个值, 区间长度要 $\ge 3$</p>
<p>输出最大的 $v$ </p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>$1\le t \le 10^{5}$ , $3\le n\le 10^{5}$ , $1\le b_{i} \le 10^{8}$</p>
<p>$t$ 个样例, 每个样例 $n$ 个 $b_{i}$ </p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$v&#x3D;b_{i1}+b_{i2}+b_{i3}-(r-l)$ , 要让v最大, 我们就想让 $r-l$ 尽可能小, 不妨设 $i1 &lt; i2&lt; i3$ 且</p>
<p>$r &#x3D; i3$ , $l &#x3D; i1$ , 那么式子就变成了 $v &#x3D; (b_{i1}+i1)+b_{i2}+(b_{i3}-i3)$ </p>
<p>这样我们枚举中间位置 $b_{i2}$ , 找到它左边和右边对应部分的最大值即可, 有点类似那个接雨水的问题</p>
<p>而找到左边和右边的最大值, 可以用 <strong>DP</strong> 来实现 </p>
<p>代码其实不难, 主要是要想通上边这个式子的变形, 用到了贪心的思想</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N], l[N], r[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">		l[<span class="number">2</span>] = a[<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//l[i]表示i左边的最大值, 不包括位置i</span></span><br><span class="line">			l[i] = <span class="built_in">max</span>(a[i - <span class="number">1</span>] + (i - <span class="number">1</span>), l[i - <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		r[n - <span class="number">1</span>] = a[n] - n;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">1</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			r[i] = <span class="built_in">max</span>(a[i + <span class="number">1</span>] - (i + <span class="number">1</span>), r[i + <span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//枚举每个中间位置</span></span><br><span class="line">		<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n - <span class="number">1</span>; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ans = <span class="built_in">max</span>(ans, l[i] + r[i] + a[i]);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1827A/</url>
    <content><![CDATA[<h1 id="Counting-Orders"><a href="#Counting-Orders" class="headerlink" title="Counting Orders"></a>Counting Orders</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>求有多少种重新排列 $a$ 的方式，使得对于任意 $1\le i\le n$，都满足 $a_i&gt;b_i$，结果对 $10^9+7$ 取模。 </p>
<p>$1\le n\le 2\times 10^5,1\le a_i,b_i\le 10^9$，保证 $a_i$ 互不相同。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two arrays $ a $ and $ b $ each consisting of $ n $ integers. All elements of $ a $ are pairwise distinct.</p>
<p>Find the number of ways to reorder $ a $ such that $ a_i &gt; b_i $ for all $ 1 \le i \le n $ , modulo $ 10^9 + 7 $ .</p>
<p>Two ways of reordering are considered different if the resulting arrays are different.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^{5} $ ) — the length of the array $ a $ and $ b $ .</p>
<p>The second line of each test case contains $ n $ distinct integers $ a_1 $ , $ a_2 $ , $ \ldots $ , $ a_n $ ( $ 1 \le a_i \le 10^9 $ ) — the array $ a $ . It is guaranteed that all elements of $ a $ are pairwise distinct.</p>
<p>The second line of each test case contains $ n $ integers $ b_1 $ , $ b_2 $ , $ \ldots $ , $ b_n $ ( $ 1 \le b_i \le 10^9 $ ) — the array $ b $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^{5} $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the number of ways to reorder array $ a $ such that $ a_i &gt; b_i $ for all $ 1 \le i \le n $ , modulo $ 10^9 + 7 $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">6</span> <span class="number">8</span> <span class="number">4</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">1</span> <span class="number">5</span> <span class="number">6</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">7</span> <span class="number">10</span> <span class="number">23</span> <span class="number">28</span> <span class="number">29</span> <span class="number">50</span> <span class="number">69</span> <span class="number">135</span> <span class="number">420</span> <span class="number">1000</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> <span class="number">13</span> <span class="number">21</span> <span class="number">34</span> <span class="number">55</span> <span class="number">89</span> <span class="number">144</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">32</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">0</span><br><span class="line">13824</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>常理来说，我们肯定要先解决 $b$ 里边大的数，所以我们把 $b$ 降序排列，保证大的数先被遍历到，同时我们肯定希望在合法的前提下，能先尽可能考虑 $a$ 里边小的数，所以我们把 $a$ 升序排列<br>然后遍历 $b$ ，对于 $b[i]$，我们找到 $a$ 中第一个大于 $b[i]$ 的数记 $a[k]$ ，$a$ 中有 $(n - k)$ 个数大于 $b[i]$ ，因为 $b$ 降序，所以 $n-k$ 个数中有一些已经被分配去对抗大于 $b[i]$ 的 数，遍历到 $b[i]$ 时 $a$ 中就有 $i$ 个数被分去对抗大于 $b[i]$ 的数，所以对于 $b[i]$ 剩下 $(n - k - i)$ 种方案，方案数最小是 $0$。<br>其实就是个排列组合问题</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; a, b;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">			a.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//a升序</span></span><br><span class="line">		<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> t;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">			b.<span class="built_in">push_back</span>(t);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//b降序</span></span><br><span class="line">		<span class="built_in">sort</span>(b.<span class="built_in">rbegin</span>(), b.<span class="built_in">rend</span>());</span><br><span class="line">		<span class="comment">//遍历b</span></span><br><span class="line">		ll ans = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//找到第一个大于bi的ak, upper_bound 用二分查找出第一个大于 b[i] 的数</span></span><br><span class="line">			<span class="type">int</span> t = n - (<span class="built_in">upper_bound</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), b[i]) - a.<span class="built_in">begin</span>()) - i;	<span class="comment">// n-k-i</span></span><br><span class="line">			ans = ans * <span class="built_in">max</span>(t, <span class="number">0</span>) % mod;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %ld\n&quot;</span>, ans);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1826C/</url>
    <content><![CDATA[<h1 id="CF1826C"><a href="#CF1826C" class="headerlink" title="CF1826C"></a>CF1826C</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>n个程序员, m个算法</p>
<p>每一轮, n个程序员对剩余算法投票, 只有票数最多的算法会被保留, 可能不止保留一个</p>
<p>问有没有可能无限进行, 输出yes代表一定会结束, 输出no代表有可能无限进行下去</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>$t\le10^{5}$, $1\le n,m\le10^{6}$</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>要想不结束, 可以让 $n$ 平均分配到 $k$ 个选项上, 我们找出 $n$ 的最小因数, 看它是否小于 $m$ 即可判断</p>
<p>复杂度为 $O(n)$ </p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1827B1/</url>
    <content><![CDATA[<h1 id="Range-Sorting-Easy-Version"><a href="#Range-Sorting-Easy-Version" class="headerlink" title="Range Sorting (Easy Version)"></a>Range Sorting (Easy Version)</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>对一个数组 ${p_i}$ 的一段区间 $[l,r]$ 排序的代价为 $r-l$ ，对整个数组 $p_i$ 排序的代价为选定若干区间并排序，使得整个数组有序的代价之和。</p>
<p>求 ${a_i}$ 的所有子段排序的代价之和。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The only difference between this problem and the hard version is the constraints on $ t $ and $ n $ .</p>
<p>You are given an array $ a $ , consisting of $ n $ distinct integers $ a_1, a_2, \ldots, a_n $ .</p>
<p>Define the beauty of an array $ p_1, p_2, \ldots p_k $ as the minimum amount of time needed to sort this array using an arbitrary number of range-sort operations. In each range-sort operation, you will do the following:</p>
<ul>
<li>Choose two integers $ l $ and $ r $ ( $ 1 \le l &lt; r \le k $ ).</li>
<li>Sort the subarray $ p_l, p_{l + 1}, \ldots, p_r $ in $ r - l $ seconds.</li>
</ul>
<p>Please calculate the sum of beauty over all subarrays of array $ a $ .</p>
<p>A subarray of an array is defined as a sequence of consecutive elements of the array.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 5 \cdot 10^3 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 5 \cdot 10^3 $ ) — the length of the array $ a $ .</p>
<p>The second line of each test case consists of $ n $ integers $ a_1,a_2,\ldots, a_n $ ( $ 1\le a_i\le 10^9 $ ). It is guaranteed that all elements of $ a $ are pairwise distinct.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 5 \cdot 10^3 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the sum of beauty over all subarrays of array $ a $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">10</span> <span class="number">6</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">8</span> <span class="number">7</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">8</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">6</span> <span class="number">13</span> <span class="number">3</span> <span class="number">15</span> <span class="number">5</span> <span class="number">10</span> <span class="number">8</span> <span class="number">16</span> <span class="number">9</span> <span class="number">11</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">8</span><br><span class="line">16</span><br><span class="line">232</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>给我们一个数组 $a$ 要求我们求出对 $a$ <strong>所有子区间</strong>排序所需要的最小花费<br>我们可以总结出两个规律：</p>
<ol>
<li>每次选择的一定是不交区间, 这个很好理解<br>比如我们要对区间 $[l, r]$ 排序，选 $[l, l + k]$ 和 $[l + k - 1, r]$ 的花费一定比直接选择 $[l, r]$ 排序来的要大</li>
<li>独立的处理每个不交子区间<strong>不劣于</strong>处理整个大区间, 说人话就是把一段分成尽量多段可以降低代价<br>$cost(l, r) &#x3D; cost(l, l + k) + cost(l + k + 1, r) + 1$</li>
</ol>
<p>对于 $[l ,r]$ 如果存在 $k$ 可以把区间分成两段排序，那么就有左区间最大值小于右区间最小值的性质，即 $Max_{左} &lt; Min_{右}$</p>
<p>但是如果遍历每一个区间，找到每个区间内的分界点太复杂了且会超时，<strong>所以我们遍历 $i$ ，看 $a[i]$ 可以成为哪些区间的划分点</strong>，同时为了方便操作我们根据大小把数组 $a$ 内的元素映射成 $1$ 到 $n$ 方便后续操作且对答案没有影响</p>
<p>首先我们遍历 $i$ 的右边，维护在区间 $[i + 1, k]$ 的最小值，并统计以这个值为最小值的 $i$ 的右边的区间（以 $i + 1$ 为起点）一共有多少个. </p>
<p>等遍历完之后，我们可以以前缀和的方式计算出在 $i$ 的右边，有多少个区间的最小值 $\ge x$ ， 我们再遍历 $i$ 的左边，找到左边每个区间 (以 $i$ 为终点) 的最大值 $x$，这样就找到了有多少个满足 $Max_{左} &lt; Min_{右}$ 的可以用 $a[i]$ 划分的区间了</p>
<p>记得答案要用 <code>long long</code> 存，不然会溢出</p>
<p><strong>解释一下阅读代码时可能会困惑的地方</strong></p>
<p>为了方便理解, 我们找分界点可以理解为在这砍一刀, 可以砍一次就可以代价减少1</p>
<ul>
<li><p>为什么一开始算最大代价的时候不用排除 “区间本身是有序不用排序” 的情况, 而选择全部计算呢</p>
<p>这是因为后边我们再找可以在哪里砍一刀的时候是可以排除这个错误的. 要注意, 一个区间如果有序, 那么不就说明这个区间的每一个元素上都可以砍一刀, 那按照后边的代码逻辑, 我们是可以找出来每一个可以砍一刀的地方的, 所以也就可以排除”区间本身是有序不用排序”的误差. 例如原序列 <code>12345</code> , 我们按需要排序来计算代价那么 <code>mc = 4</code>, 但是我们可以发现每个元素都可以作为分界点, 那我们就会找到 <code>1</code>, <code>2</code>, <code>3</code>, <code>4</code> 可以作为分界点, 代价就会减少4, 最终是0, 所以保证了一开始这么计算最大代价是没问题的</p>
</li>
<li><p>一个区间可以有很多个分界点, 所以我们选择遍历 a[i], 不要想错了</p>
</li>
<li><p>为什么要对 sum数组 求前缀和?</p>
<p><code>mc -= sum[maxv + 1]</code> 这个是我们计算代价可以减少多少的一步, 我们的逻辑是看看右边有多少个区间的最小值能大于左边到目前为止的区间最大值, 比如 maxv &#x3D; 95, 那么要减去 sum[96]. 回忆我们还未求前缀和之前的 sum数组 所代表的是什么, sum[96] 只代表最小值是 96 的区间个数, 所以要求前缀和. 减去 sum[96] 就代表着: 右边有这么多个最小值是 96 ~ 很大数 的区间, 他们都能和现在左边这个位置组成一个区间, 这个区间可以以 a[i] 为分界点</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">5e3</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">int</span> b[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> v, id;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(A p, A q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> p.v &lt; q.v;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i].v);</span><br><span class="line">			a[i].id = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, cmp);	<span class="comment">//要从下标为1开始排</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//按排序映射成1~n 方便处理</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">//要放在本来的位置</span></span><br><span class="line">			b[a[i].id] = i;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//最大代价就是每一个子区间都要排序</span></span><br><span class="line">		ll mc = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) mc += i * (n - i);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//枚举每一个可以断开的点</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> sum[N] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">			<span class="comment">//找出以 i + 1 为起点的区间内的最小值 并记录有几段区间的最小值是这个数</span></span><br><span class="line">			<span class="type">int</span> minv = <span class="number">1e9</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				minv = <span class="built_in">min</span>(minv, b[j]);</span><br><span class="line">				sum[minv]++;	<span class="comment">//这里sum[q]表示以q为最小值的区间个数</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">			&#123;</span><br><span class="line">				sum[j] += sum[j + <span class="number">1</span>];	<span class="comment">//这里sum[q]表示最小值大于等于q的区间个数, 是类似前缀和方式</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> maxv = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j = i; j &gt; <span class="number">0</span>; j--)</span><br><span class="line">			&#123;</span><br><span class="line">				maxv = <span class="built_in">max</span>(maxv, b[j]);</span><br><span class="line">				mc -= sum[maxv + <span class="number">1</span>];	<span class="comment">//因为b内只有 1~n 且没有重复元素, 所以直接+1就可以表示了</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %lld\n&quot;</span>, mc);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1828A/</url>
    <content><![CDATA[<h1 id="Divisible-Array"><a href="#Divisible-Array" class="headerlink" title="Divisible Array"></a>Divisible Array</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>构造一个长度为 $n$ 的序列 $a$ 满足以下条件。</p>
<ul>
<li>对于每个元素 $a_i$ 满足 $a_i \le 1000$。</li>
<li>对于每个元素 $a_i$ 满足 $a_i \equiv 0 \pmod i$。即每个元素 $a_i$ 能被 $i$ 整除。</li>
<li>满足 $\sum_{i &#x3D; 1}^{n} a_i \equiv 0 \pmod n$。即所有元素之和能被 $n$ 整除。</li>
</ul>
<p>$n \leq 200$。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a positive integer $ n $ . Please find an array $ a_1, a_2, \ldots, a_n $ that is perfect.</p>
<p>A perfect array $ a_1, a_2, \ldots, a_n $ satisfies the following criteria:</p>
<ul>
<li>$ 1 \le a_i \le 1000 $ for all $ 1 \le i \le n $ .</li>
<li>$ a_i $ is divisible by $ i $ for all $ 1 \le i \le n $ .</li>
<li>$ a_1 + a_2 + \ldots + a_n $ is divisible by $ n $ .</li>
</ul>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 200 $ ). The description of the test cases follows.</p>
<p>The only line of each test case contains a single positive integer $ n $ ( $ 1 \le n \le 200 $ ) — the length of the array $ a $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output an array $ a_1, a_2, \ldots, a_n $ that is perfect.</p>
<p>We can show that an answer always exists. If there are multiple solutions, print any.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">7</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td></tr></table></figure>





<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">8</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">9</span> <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span> <span class="number">18</span> <span class="number">8</span> <span class="number">5</span> <span class="number">36</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">6</span> <span class="number">21</span> <span class="number">24</span> <span class="number">10</span> <span class="number">6</span> <span class="number">14</span></span><br></pre></td></tr></table></figure>




<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>切入点在任何数都可以整除1, 所以第一个位置上可以放大于等于1的任何数字(题目要求元素要大于等于1)</p>
<p>要求 <code>a[i] % i == 0 &amp;&amp; (a[1] + a[2] + ... + a[n]) % n == 0</code><br>任何数都能被1整除，那我们让 <code>a[i] = i</code>，最后的差由 <code>a[1]</code> 来补齐，又因为要求 <code>a[i] &gt;= 1</code>，避免<code>a[1] == 0</code> 的情况出现，我们令 <code>a[1] += n</code>，这样总和仍能被n整除</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre><code class="cpp">#include &lt;iostream&gt;
using namespace std;
const int N = 210;
int main()
&#123;
    int t;
    scanf(&quot;%d&quot;, &amp;t);
    while (t--)
    &#123;
        int n;
        scanf(&quot;%d&quot;, &amp;n);
        if (n == 1)
        &#123;
            printf(&quot;1\n&quot;);
            continue;
        &#125;
        int res = (n - 1) * (n + 2) / 2;
        printf(&quot;%d &quot;, 2 * n - (res % n));
        for (int i = 2; i &lt;= n; i++)
            printf(&quot;%d &quot;, i);
        printf(&quot;\n&quot;);
    &#125;
&#125;
</code></pre>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1828B/</url>
    <content><![CDATA[<h1 id="Permutation-Swap"><a href="#Permutation-Swap" class="headerlink" title="Permutation Swap"></a>Permutation Swap</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给你一个长度为 $n$ 的未排序的排列。找到最大的整数 $k$ 满足可以通过只交换<strong>下标差为 $k$</strong> 的元素使排列被从小到大排序。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given an unsorted permutation $ p_1, p_2, \ldots, p_n $ . To sort the permutation, you choose a constant $ k $ ( $ k \ge 1 $ ) and do some operations on the permutation. In one operation, you can choose two integers $ i $ , $ j $ ( $ 1 \le j &lt; i \le n $ ) such that $ i - j &#x3D; k $ , then swap $ p_i $ and $ p_j $ .</p>
<p>What is the maximum value of $ k $ that you can choose to sort the given permutation?</p>
<p>A permutation is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2, 3, 1, 5, 4] $ is a permutation, but $ [1, 2, 2] $ is not a permutation ( $ 2 $ appears twice in the array) and $ [1, 3, 4] $ is also not a permutation ( $ n &#x3D; 3 $ but there is $ 4 $ in the array).</p>
<p>An unsorted permutation $ p $ is a permutation such that there is at least one position $ i $ that satisfies $ p_i \ne i $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 10^{5} $ ) — the length of the permutation $ p $ .</p>
<p>The second line of each test case contains $ n $ distinct integers $ p_1, p_2, \ldots, p_n $ ( $ 1 \le p_i \le n $ ) — the permutation $ p $ . It is guaranteed that the given numbers form a permutation of length $ n $ and the given permutation is unsorted.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2 \cdot 10^{5} $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the maximum value of $ k $ that you can choose to sort the given permutation.</p>
<p>We can show that an answer always exists.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">6</span> <span class="number">7</span> <span class="number">5</span> <span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">6</span> <span class="number">7</span> <span class="number">4</span> <span class="number">9</span> <span class="number">2</span> <span class="number">3</span> <span class="number">8</span> <span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span> <span class="number">3</span> <span class="number">4</span> <span class="number">2</span> <span class="number">6</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">10</span> <span class="number">5</span> <span class="number">2</span> <span class="number">9</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">1</span> <span class="number">4</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">11</span> <span class="number">6</span> <span class="number">4</span> <span class="number">8</span> <span class="number">3</span> <span class="number">7</span> <span class="number">5</span> <span class="number">9</span> <span class="number">10</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>


<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为数组中元素只有 $1\sim n$，数字 $i$ 的初始位置为 $x$，它最后的位置应该要在 $i$ (下标从1开始)，也即 <code>(x - i) % k == 0</code>，那我们只需要求出每个数的初末位置的差值，然后求所有差值的最大公约数即可</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"><span class="comment">//求最大公因数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> q ? <span class="built_in">gcd</span>(q, p % q) : p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">			a[i] = <span class="built_in">abs</span>(a[i] - i);	<span class="comment">//存需要移动的距离</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">int</span> k = <span class="built_in">gcd</span>(a[<span class="number">1</span>], a[<span class="number">2</span>]);</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">			k = <span class="built_in">gcd</span>(k, a[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot; %d\n&quot;</span>, k);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1830B/</url>
    <content><![CDATA[<h1 id="The-BOSS-Can-Count-Pairs"><a href="#The-BOSS-Can-Count-Pairs" class="headerlink" title="The BOSS Can Count Pairs"></a>The BOSS Can Count Pairs</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>多组数据。</p>
<p>每组数据给你一个 $n$ 和两个序列 $a,b$。</p>
<p>求有多少个数对 $(i,j)$ 满足 $1 \le i &lt; j \le n$ 且 $a_i \times a_j &#x3D; b_i + b_j$</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two arrays $ a $ and $ b $ , both of length $ n $ .</p>
<p>Your task is to count the number of pairs of integers $ (i,j) $ such that $ 1 \leq i &lt; j \leq n $ and $ a_i \cdot a_j &#x3D; b_i+b_j $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line of input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 2 \le n \le 2 \cdot 10^5 $ ) — the length of the arrays.</p>
<p>The second line of each test case contains $ n $ integers $ a_1,a_2,\ldots,a_n $ ( $ 1 \le a_i \le n $ ) — the elements of array $ a $ .</p>
<p>The third line of each test case contains $ n $ integers $ b_1,b_2,\ldots,b_n $ ( $ 1 \le b_i \le n $ ) — the elements of array $ b $ .</p>
<p>It is guaranteed that the sum of $ n $ across all test cases does not exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output the number of good pairs.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span> <span class="number">1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">2</span> <span class="number">8</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">7</span> <span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span> <span class="number">8</span> <span class="number">8</span> <span class="number">1</span> <span class="number">1</span> <span class="number">6</span> <span class="number">5</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>



<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">7</span><br><span class="line">1</span><br></pre></td></tr></table></figure>



<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>$a[i]\times a[j] &#x3D; b[i] + b[j]$ , 我们不难发现, $a[i]$ 和 $a[j]$ 至少有一个 $\le \sqrt{2n}$ , 我们分类讨论一下</p>
<ul>
<li><p>当 $a[i]&#x3D;a[j]$ 的时候, </p>
<p>毫无疑问, 都要满足 $\le \sqrt{2n}$, 我们枚举 $a[i]$, 满足条件的我们计算 $b[j]$, 因为 $a[i]$ 和 $b[i]$ 已知, 我们可以直接计算出 $b[j]$, 然后我们看”桶”里有没有一个 $a[j]&#x3D;a[i]$ 的拥有我们需要的 $b[j]$</p>
<p>需要注意的是, 如果自己和自己也满足条件, 是有可能找到自己的, 需要排除这种情况, 比如说能满足 $a[i]\times a[i] &#x3D; b[i] + b[i]$ 的一对 $ab$ 一共有 $n$ 对, 那么遍历到第一对 $ab$ 的时候, 它会和自己组成一次, 遍历到第二对 $ab$ 的时候, 它会和自己组成一次, 以此类推, 所以最终答案要减去能满足这个条件的 $ab$ 的对数</p>
<p>不仅如此, 如果 $a_1b_1$ 可以与 $a_2b_2$ 组队, 那么我们遍历到 $a_1b_1$ 的时候它找到了 $a_2b_2$, 我们遍历 $a_2b_2$ 的时候又找到了 $a_1b_1$, 同样的结果被计算了两次, 所以在减去”自己找自己”之后还要除个2</p>
</li>
<li><p>当 $a[i]\neq a[j]$ 的时候</p>
<p>两个 $a$ 肯定一大一小, 我们可以枚举 $a[i]$, 然后去找有没有对应的合法的 $a[j]$ 能够满足</p>
<p>$a[i]\times a[j] \le 2n$ 的情况, 如果有, 我们再进一步算出 $a[j]$ 是否有合法的 $b[j]$, 在找 $a[j]$ 的时候我们直接从1开始枚举 $a[j]$ 的值, 直到不满足 $a[i]\times a[j] \le 2n$, 且为了不重复, 我们要求 $a[i]&gt;j$</p>
<p>那为什么一定要求 $a[i]&gt;j$ 呢? 能不能反过来呢?</p>
<p>我们发现在处理第一种情况的时候, 两个 $a$ 都是小于 $\sqrt{2n}$ 的, 我们的桶也是存的满足这个条件的 $a$ 的值, 并不是说合法的 $a$ 一定要满足这个条件, 因为当其中一个 $a$ 变小, 另一个 $a$ 可以变大, 大到超过 $\sqrt{2n}$, 我们枚举每一个 $a[i]$, 包括那些超过 $\sqrt{2n}$ 的, 那么这些超过 $\sqrt{2n}$ 的如果能找到答案, 那么那一个 $a$ 一定是小于 $\sqrt{2n}$, 所以代码中是 <code>ans += f[j][t]</code>, 因为小的在桶里, 大的不在</p>
<p>那为什么不把所有的存起来呢? 是因为数组不允许开那么大</p>
</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span>  ll;</span><br><span class="line"><span class="type">int</span> f[<span class="number">635</span>][N], a[N], b[N];	<span class="comment">//635是 2N开根号</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		ll lim = <span class="built_in">sqrt</span>(n * <span class="number">2</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; b[i];</span><br><span class="line">			<span class="keyword">if</span>(a[i] &lt;= lim) f[a[i]][b[i]]++;	<span class="comment">//只存小的</span></span><br><span class="line">		&#125;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] &lt;= lim &amp;&amp; a[i] * a[i] - b[i] &gt; <span class="number">0</span> &amp;&amp; a[i] * a[i] - b[i] &lt;= n)</span><br><span class="line">				ans += f[a[i]][a[i] * a[i] - b[i]];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= lim; i += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			ans -= f[i][i * i / <span class="number">2</span>];	<span class="comment">//去掉自己找自己</span></span><br><span class="line">		&#125;</span><br><span class="line">		ans /= <span class="number">2</span>;	<span class="comment">//去重</span></span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; a[i] * j &lt;= <span class="number">2</span> * n &amp;&amp; a[i] &gt; j; j++)	<span class="comment">//直接枚举aj的值 </span></span><br><span class="line">			&#123;</span><br><span class="line">					ll t = a[i] * j - b[i];</span><br><span class="line">					<span class="keyword">if</span>(t &gt; <span class="number">0</span> &amp;&amp; t &lt;= n) ans += f[j][t];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			<span class="keyword">if</span>(a[i] &lt;= lim) f[a[i]][b[i]] = <span class="number">0</span>;	<span class="comment">//清空, 存了的才清空</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1834B/</url>
    <content><![CDATA[<h1 id="Maximum-Strength"><a href="#Maximum-Strength" class="headerlink" title="Maximum Strength"></a>Maximum Strength</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>每一种材料的力量由一个十进制整数表示。</p>
<p>对于一个武器，由<strong>两种</strong>材料构成。假如第一种材料的力量为 $X &#x3D; \overline{x_1x_2 \dots x_n}$，第二种材料的力量为 $Y &#x3D; \overline{y_1y_2 \dots y_n}$，那么这个武器的力量为 $\sum_{i &#x3D; 1}^n |x_i - y_i|$，也就是 $|x_1 - y_1| + |x_2 - y_2| + \dots + |x_n - y_n|$。</p>
<p><strong>如果两个数字长度不一样，则要将短的数字用前导零补成相同长度</strong>。</p>
<p>现在，你拥有<strong>无数个</strong>力量在 $[L, R]$ 中的材料。你想要选出<strong>两个</strong>材料做出一个力量<strong>最大</strong>的武器。请你求出你设计出的武器力量的最大值。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>Fedya is playing a new game called “The Legend of Link”, in which one of the character’s abilities is to combine two materials into one weapon. Each material has its own strength, which can be represented by a positive integer $ x $ . The strength of the resulting weapon is determined as the sum of the absolute differences of the digits in the decimal representation of the integers at each position.</p>
<p>Formally, let the first material have strength $ X &#x3D; \overline{x_{1}x_{2} \ldots x_{n}} $ , and the second material have strength $ Y &#x3D; \overline{y_{1}y_{2} \ldots y_{n}} $ . Then the strength of the weapon is calculated as $ |x_{1} - y_{1}| + |x_{2} - y_{2}| + \ldots + |x_{n} - y_{n}| $ . If the integers have different lengths, then the shorter integer is padded with leading zeros.</p>
<p>Fedya has an unlimited supply of materials with all possible strengths from $ L $ to $ R $ , inclusive. Help him find the maximum possible strength of the weapon he can obtain.</p>
<p>An integer $ C &#x3D; \overline{c_{1}c_{2} \ldots c_{k}} $ is defined as an integer obtained by sequentially writing the digits $ c_1, c_2, \ldots, c_k $ from left to right, i.e. $ 10^{k-1} \cdot c_1 + 10^{k-2} \cdot c_2 + \ldots + c_k $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 500 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers $ L $ and $ R $ ( $ 1 \le L \le R &lt; 10^{100} $ ) — the decimal representation of the integers representing the minimum and maximum strength of the materials that Fedya has. It is guaranteed that the integers $ L $ and $ R $ do not contain leading zeros.</p>
<p>Note that the input data may not fit into standard $ 32 $ -bit or $ 64 $ -bit integer data types.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case print one integer — the maximum possible strength of the weapon that Fedya can obtain from the given materials.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">53 </span><span class="number">57</span></span><br><span class="line"><span class="symbol">179 </span><span class="number">239</span></span><br><span class="line"><span class="symbol">13 </span><span class="number">37</span></span><br><span class="line"><span class="symbol">132228 </span><span class="number">132228</span></span><br><span class="line"><span class="symbol">54943329752812629795 </span><span class="number">55157581939688863366</span></span><br><span class="line"><span class="symbol">88 </span><span class="number">1914</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">19</span><br><span class="line">11</span><br><span class="line">0</span><br><span class="line">163</span><br><span class="line">28</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当某个位置一个是9, 一个是0的时候, 他们的差值是最大的, 那我们考虑可不可以选出两个数, 使得其中一个的9尽可能多, 另一个的0尽可能多</p>
<p>对于上界R, 我们如果要让一个数从不是9变成9, 有很多限制, 如果要不使得上界增加, 我们还得选几个位置去缩小, 不仅麻烦, 且并不符合我们要找<strong>尽可能多</strong>的9的思路, 对于下界L要让非0变成0也是如此</p>
<p>那既然上界不能变大, 下界不能变小, 那我们就在下界基础上增加, 上界基础上减小, 保证数字仍在合法区间不就行了吗</p>
<p><strong>!</strong>: 我们并不是改变上下区间, 只是在这个基础上增加减小, 以下说R变小L变大是为了方便叙述</p>
<p>我们只需要让R的最高位始终大于等于L的最低位, 那不管后边的数怎么变, R仍旧大于等于L, 且因为我们要在L上递增, R上递减, 所以就能保证我们找到的数字在合法的区间内了.</p>
<p>解释一下 check函数 的逻辑, 从高位往低位, R肯定至少有一位要比L大, 因为R是上界, L是下界, 我们从高位往低位遍历, 直到当前位置(不包括)为止, 只要有一位R比L大, 那就可以让R的这一位变成0, L的这一位变成9. </p>
<p><strong>!</strong>: 数字太长先用 string 存然后一位一位放到 vector 里, 按照我的 get函数 和 check函数 的逻辑来看, vector的低位置放的是数字的低位, 但是 string 中数字的最高位是在0的位置, 我们读入后要记得 reverse 一下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; L, R;</span><br><span class="line">string l, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> cur)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = R.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt; cur; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(L[i] &lt; R[i]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; r[i]; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		R.<span class="built_in">push_back</span>(r[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; R.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(i &lt; l.<span class="built_in">size</span>()) L.<span class="built_in">push_back</span>(l[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">		<span class="keyword">else</span> L.<span class="built_in">push_back</span>(<span class="number">0</span>);	<span class="comment">//L可能比R短, 所以要补前导0 </span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; R.<span class="built_in">size</span>(); i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">check</span>(i))	<span class="comment">//可以下边变9, 上边变0</span></span><br><span class="line">		&#123;</span><br><span class="line">			ans += <span class="number">9</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> ans += R[i] - L[i]; </span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">		<span class="built_in">reverse</span>(l.<span class="built_in">begin</span>(), l.<span class="built_in">end</span>()), <span class="built_in">reverse</span>(r.<span class="built_in">begin</span>(), r.<span class="built_in">end</span>());</span><br><span class="line">		cout &lt;&lt; <span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">		L.<span class="built_in">clear</span>(), R.<span class="built_in">clear</span>(); </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1834C/</url>
    <content><![CDATA[<h1 id="Game-with-Reversing"><a href="#Game-with-Reversing" class="headerlink" title="Game with Reversing"></a>Game with Reversing</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>小 L 和小 S 在玩游戏。他们有两个长度均为 $n(1 \le n \le 10^5)$ 的字符串 $S, T$，小 L 和小 S 轮流操作，小 L 先手。</p>
<p>小 L 的回合，他可以选择 $1 \to n$ 中的一个整数 $i$，再选择串 $S$ 或 $T$，把其中的第 $i$ 个字符改成任意一个字符 $c$。</p>
<p>小 S 的回合，她可以选择 $S$ 或 $T$，并将它进行翻转。</p>
<p>如果两个串 $S, T$ 经过若干次操作后相等，则游戏立即结束。小 L 希望总操作次数最小，小 S 希望总操作次数最大。两人都采取最优策略，问最终操作次数。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Alice and Bob are playing a game. They have two strings $ S $ and $ T $ of the same length $ n $ consisting of lowercase latin letters. Players take turns alternately, with Alice going first.</p>
<p>On her turn, Alice chooses an integer $ i $ from $ 1 $ to $ n $ , one of the strings $ S $ or $ T $ , and any lowercase latin letter $ c $ , and replaces the $ i $ -th symbol in the chosen string with the character $ c $ .</p>
<p>On his turn, Bob chooses one of the strings $ S $ or $ T $ , and reverses it. More formally, Bob makes the replacement $ S :&#x3D; \operatorname{rev}(S) $ or $ T :&#x3D; \operatorname{rev}(T) $ , where $ \operatorname{rev}(P) &#x3D; P_n P_{n-1} \ldots P_1 $ .</p>
<p>The game lasts until the strings $ S $ and $ T $ are equal. As soon as the strings become equal, the game ends instantly.</p>
<p>Define the duration of the game as the total number of moves made by both players during the game. For example, if Alice made $ 2 $ moves in total, and Bob made $ 1 $ move, then the duration of this game is $ 3 $ .</p>
<p>Alice’s goal is to minimize the duration of the game, and Bob’s goal is to maximize the duration of the game.</p>
<p>What will be the duration of the game, if both players play optimally? It can be shown that the game will end in a finite number of turns.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the strings $ S $ and $ T $ .</p>
<p>The second line of each test case contains a string $ S $ of length $ n $ consisting of lowercase latin letters.</p>
<p>The third line of each test case contains a string $ T $ of length $ n $ consisting of lowercase latin letters.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output a single number on a separate line — the duration of the described game, if both players play optimally.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">abcde</span><br><span class="line">abxde</span><br><span class="line"><span class="number">5</span></span><br><span class="line">hello</span><br><span class="line">olleo</span><br><span class="line"><span class="number">2</span></span><br><span class="line">ab</span><br><span class="line">cd</span><br><span class="line"><span class="number">7</span></span><br><span class="line">aaaaaaa</span><br><span class="line">abbbbba</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="selector-tag">q</span></span><br><span class="line"><span class="selector-tag">q</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">yoyoyo</span><br><span class="line">oyoyoy</span><br><span class="line"><span class="number">8</span></span><br><span class="line">abcdefgh</span><br><span class="line">hguedfbh</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">9</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们只需要盯着一个字符串看, 然后把另一个字符串改成和这个字符串或者和这个字符串的翻转一样就好了, 不要想太复杂</p>
<p>简单说明一下正确性: B的翻转对于答案是没有影响的, 比如B翻转了字符串S两次, 相当于没翻转, 或者B翻转了一次S一次T, 也相当于没翻转</p>
<p>我们判断一下两种情况有几个不同的地方要改即可, 分奇偶讨论, 要注意的是如果 dif1 &#x3D; 0, 那么直接结束, dif1 &#x3D; 1, A改一次也结束. 但是 dif2 &#x3D; 0, 先轮到A再到B, 是两次, dif2 &#x3D; 1, 还是两次. 其他情况就很简单了</p>
<p><strong>注意</strong>: 要理解好两次翻转相当于没有翻转, 不管是作用在一个字符串还是两个, 这让我们想到B是没影响的, 才可以只统计不同的字符串个数</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		string a, b; cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">		</span><br><span class="line">		<span class="type">int</span> dif1 = <span class="number">0</span>, dif2 = <span class="number">0</span>, ans = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != b[i]) dif1++;</span><br><span class="line">			<span class="keyword">if</span>(a[i] != b[n - <span class="number">1</span> - i]) dif2++;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dif1 &lt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; dif1 &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dif2 &lt;= <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(dif1 % <span class="number">2</span>) ans = <span class="built_in">min</span>(<span class="number">2</span> * dif1 - <span class="number">1</span>, ans);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dif1 % <span class="number">2</span> == <span class="number">0</span>) ans = <span class="built_in">min</span>(<span class="number">2</span> * dif1, ans);</span><br><span class="line">		<span class="keyword">if</span>(dif2 % <span class="number">2</span>) ans = <span class="built_in">min</span>(ans, <span class="number">2</span> * dif2);</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(dif2 % <span class="number">2</span> == <span class="number">0</span>) ans = <span class="built_in">min</span>(ans, dif2 * <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1834D/</url>
    <content><![CDATA[<h1 id="Survey-in-Class"><a href="#Survey-in-Class" class="headerlink" title="Survey in Class"></a>Survey in Class</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有 $n$ 个学生同时对课堂内容进行了预习。有 $m$ 个问题，第 $i$ 个人预习的问题是一个区间，可以用 $[l_i,r_i]$ 表示。每当老师问出一个问题，如果一个人不会，它的分数就会 $-1$，否则 $+1$。注意，分数可能为负。</p>
<p>现在你要问一些不重复的问题，最大化学生分数的极差，并输出这个值。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Zinaida Viktorovna has $ n $ students in her history class. The homework for today included $ m $ topics, but the students had little time to prepare, so $ i $ -th student learned only topics from $ l_i $ to $ r_i $ inclusive.</p>
<p>At the beginning of the lesson, each student holds their hand at $ 0 $ . The teacher wants to ask some topics. It goes like this:</p>
<ul>
<li>The teacher asks the topic $ k $ .</li>
<li>If the student has learned topic $ k $ , then he raises his hand by $ 1 $ , otherwise he lower it by $ 1 $ .</li>
</ul>
<p>Each topic Zinaida Viktorovna can ask no more than one time.</p>
<p>Find the maximum difference of the heights of the highest and the lowest hand that can be in class after the survey.</p>
<p>Note that the student’s hand can go below $ 0 $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains the number of test cases $ t $ ( $ 1 \le t \le 10^4 $ ). The description of the test cases follows.</p>
<p>The first line of each test case contains two integers $ n $ and $ m $ ( $ 2 \le n \le 10^5, 1 \le m \le 10^9 $ ) — the number of students and the number of topics, respectively.</p>
<p>Each of the next $ n $ lines of each test case contain two integers $ l_i $ and $ r_i $ ( $ 1 \le l_i \le r_i \le m $ ) — the endpoints of the segment of topics that $ i $ -th student has learned.</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print one integer — the maximum difference of the heights of the highest and the lowest hand that can be in the class after the survey.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">4</span><br><span class="line">0</span><br><span class="line">2</span><br><span class="line">12</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>为了差值最大化, 我们肯定要找一段自己有的, 这样子自己可以加分, 别人就要减分, 是最赚的</p>
<p>对于段与段之间的关系, 我们进行分类讨论</p>
<ul>
<li><p>包含与被包含</p>
<p>很明显自己有的别人没有的部分 $&#x3D;(r2-r1)+(l1-l2)&#x3D;(r2-l2)-(r1-l1)$, 所以我们分别维护一个最大的 还有最小的 $r-l$ 就可以了, 然后两个的差值就是这种情况的的最优答案</p>
<p>我们不用判断两段之间是否满足这种情况, 因为如果不满足我们在另一种情况讨论, 结果肯定会比这个计算结果要优, 我们取最大值的时候就会自动排除不符合的情况的</p>
<img src="CF1834D.assets/f1.jpg" alt="f1" style="zoom:67%;" />
</li>
<li><p>相交或者分离</p>
<p>对于这种情况, 如果是相交, 那么自己有别人没有的就是右边突出来的一段 $&#x3D;r1-r2$, 如果是相离, 那就是 $r1-l1+1$, 为了是这一部分最长, 我们找到最小的那个 $r$ 即可, 让别的 $r$ 来减去即可</p>
<p>不要忘记考虑左边也会突出来一段, 与讨论右边段类似, 我们找到最大的 $l$ 让他减去其他的 $l$ 即可, 当然也要考虑相离的情况</p>
<p>和计算”包含”一样, 对所有的数求, 不判断是否满足这个关系, 因为如果是包含, 以这种计算方式计算出来的结果不会优于”包含”计算结果, 不会对答案产生影响</p>
</li>
</ul>
<p>​	       <img src="CF1834D.assets/f2.jpg" alt="f2" style="zoom:67%;" />  </p>
<p>然后对于这两种分类求出来的最大值再合在一起求个最大值即可, 主要的切入点在这个分类讨论上, 没有用到什么很高级的算法</p>
<p>所以就算是难度系数比我目前的高, 也不一定就会用到很高级的算法, 还是思维上的难度</p>
<p><strong>!</strong>: 还是那句话, 到了 10^9^, 开long long</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	ll l, r;</span><br><span class="line">&#125;a[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		ll ans = <span class="number">0</span>;</span><br><span class="line">		ll n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		ll minr = <span class="number">1e9</span>, maxl = <span class="number">-1e9</span>; </span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i].l &gt;&gt; a[i].r;</span><br><span class="line">			minr = <span class="built_in">min</span>(minr, a[i].r), maxl = <span class="built_in">max</span>(maxl, a[i].l);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//包含</span></span><br><span class="line">		ll maxn = <span class="number">-1e9</span>, minn = <span class="number">1e9</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			maxn = <span class="built_in">max</span>(maxn, a[i].r - a[i].l);</span><br><span class="line">			minn = <span class="built_in">min</span>(minn, a[i].r - a[i].l);</span><br><span class="line">		&#125;</span><br><span class="line">		ans = maxn - minn;</span><br><span class="line">		<span class="comment">//右边突出来 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i].l &gt; minr) ans = <span class="built_in">max</span>(ans, a[i].r - a[i].l + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, a[i].r - minr);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//左边突出来</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i ++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(a[i].r &lt; maxl) ans = <span class="built_in">max</span>(ans, a[i].r - a[i].l + <span class="number">1</span>);</span><br><span class="line">			<span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, maxl - a[i].l);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans * <span class="number">2</span> &lt;&lt; endl; 	<span class="comment">//自己有别人没有, 自己加1别人就要减1, 所以要这一段的值要乘2</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1837C/</url>
    <content><![CDATA[<h1 id="Best-Binary-String"><a href="#Best-Binary-String" class="headerlink" title="Best Binary String"></a>Best Binary String</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定由 <code>1</code> <code>0</code> <code>?</code> 所组成的字符串，你需要用 <code>0</code> 或 <code>1</code> 替换 <code>?</code>。</p>
<p>我们将 $s_{l},s_{l+1},\dots,s_r$ 反转成为一次操作。</p>
<p>你要使通过“反转”操作使原字符串成为升序的操作次数尽可能的小。</p>
<p>问最终构造出的字符串，有多解输出其一。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a string $ s $ consisting of the characters 0, 1 and&#x2F;or ?. Let’s call it a pattern.</p>
<p>Let’s say that the binary string (a string where each character is either 0 or 1) matches the pattern if you can replace each character ? with 0 or 1 (for each character, the choice is independent) so that the strings become equal. For example, 0010 matches ?01?, but 010 doesn’t match 1??, ??, or ????.</p>
<p>Let’s define the cost of the binary string as the minimum number of operations of the form “reverse an arbitrary contiguous substring of the string” required to sort the string in non-descending order.</p>
<p>You have to find a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 3 \cdot 10^4 $ ) — the number of test cases.</p>
<p>The first and only line of each test case contains the string $ s $ ( $ 1 \le |s| \le 3 \cdot 10^5 $ ) consisting of characters 0, 1, and&#x2F;or ?.</p>
<p>The sum of the string lengths over all test cases does not exceed $ 3 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print a binary string with the minimum possible cost among those that match the given pattern. If there are multiple answers, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="string">??</span><span class="number">01</span>?</span><br><span class="line"><span class="number">10100</span></span><br><span class="line"><span class="number">1</span>?<span class="string">?1</span>0?</span><br><span class="line"><span class="number">0</span>?<span class="number">1</span>?<span class="number">10</span>?<span class="number">10</span></span><br></pre></td></tr></table></figure>


<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">00011</span></span><br><span class="line"><span class="number">10100</span></span><br><span class="line"><span class="number">111101</span></span><br><span class="line"><span class="number">011110010</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们可以选区间 [l,r] 进行反转操作.</p>
<p>题目要求我们通过反转操作，将初始字符串变为一个非降序的字符串，并输出我们构建的这个初始串，使得反转操作的次数最少, 那我们能操作的就是 ‘?’, 我们就要关注这个 ‘?’ 要放0还是放1</p>
<p>首先我们要知道, 连续出现的相同数字, 在反转的时候可以视为一个数字, 就比如 000000 可以看作 0, 11111 可以看作 1. 比如对于 11110000 , 要让反转次数最少, 那肯定要把一整段1和一整段0调换以构成非降序</p>
<p>那这是不是就告诉我们, 如果我们可以使得连续出现相同数字的段尽可能的长, 那我们就可以让反转次数达到最少, 用例子来说明就是 11111100 只需要1次, 而 01010101001 肯定1次是操作不完的, 如果我们可以填数, 肯定要使得<strong>连续出现相同数字的那一段尽可能的长</strong></p>
<p>那如果 a[i] 是 ‘?’ 就让 a[i] &#x3D; a[i - 1] 就好了, 那如果开头是 ‘?’ 怎么办, 那就填0, 因为开头是 0 肯定符合非降序, 后续就不需要操作开头, 也符合让反转次数尽可能少 </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">3e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">char</span> s[N];</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">		<span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>) s[<span class="number">0</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; s[i]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (s[i] == <span class="string">&#x27;?&#x27;</span>) s[i] = s[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, s);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1837B/</url>
    <content><![CDATA[<h1 id="Comparison-String"><a href="#Comparison-String" class="headerlink" title="Comparison String"></a>Comparison String</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><ul>
<li>给你一个长度为 $n$ 的由 &lt; 和 &gt; 构成的字符串 $s$，如果一个数列 $a$ 能满足将字符串 $s$ 的所有大于号和小于号按顺序填入后满足大小关系，则 $a$ 数列和 $s$ 字符串是“相容的”。</li>
<li>定义一个数列的花费是这个数列中不同元素的数量。</li>
<li>已知字符串 $s$，让你求出与 $s$ 相容的所有数列中花费最小的数列的花费。</li>
</ul>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a string $ s $ of length $ n $ , where each character is either &lt; or &gt;.</p>
<p>An array $ a $ consisting of $ n+1 $ elements is compatible with the string $ s $ if, for every $ i $ from $ 1 $ to $ n $ , the character $ s_i $ represents the result of comparing $ a_i $ and $ a_{i+1} $ , i. e.:</p>
<ul>
<li>$ s_i $ is &lt; if and only if $ a_i &lt; a_{i+1} $ ;</li>
<li>$ s_i $ is &gt; if and only if $ a_i &gt; a_{i+1} $ .</li>
</ul>
<p>For example, the array $ [1, 2, 5, 4, 2] $ is compatible with the string &lt;&lt;&gt;&gt;. There are other arrays with are compatible with that string, for example, $ [13, 37, 42, 37, 13] $ .</p>
<p>The cost of the array is the number of different elements in it. For example, the cost of $ [1, 2, 5, 4, 2] $ is $ 4 $ ; the cost of $ [13, 37, 42, 37, 13] $ is $ 3 $ .</p>
<p>You have to calculate the minimum cost among all arrays which are compatible with the given string $ s $ .</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $ t $ ( $ 1 \le t \le 500 $ ) — the number of test cases.</p>
<p>Each test case consists of two lines:</p>
<ul>
<li>the first line contains one integer $ n $ ( $ 1 \le n \le 100 $ );</li>
<li>the second line contains the string $ s $ , consisting of $ n $ characters. Each character of $ s $ is either &lt; or &gt;.</li>
</ul>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print one integer — the minimum cost among all arrays which are compatible with the given string $ s $ .</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight bnf"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">4</span><br><span class="line"><span class="attribute">&lt;&lt;&gt;</span>&gt;</span><br><span class="line">4</span><br><span class="line">&gt;&gt;<span class="attribute">&lt;&lt;</span></span><br><span class="line"><span class="attribute">&gt;</span>&gt;5</span><br><span class="line">&gt;</span><br><span class="line">&gt;7</span><br><span class="line">&gt;<span class="attribute">&lt;&gt;</span><span class="attribute">&lt;&gt;</span><span class="attribute">&lt;&gt;</span><span class="attribute">&lt;</span></span><br></pre></td></tr></table></figure>
<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">3</span><br><span class="line">6</span><br><span class="line">2</span><br></pre></td></tr></table></figure>



<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>通过分析所给样例可以得出，答案是最长的连续出现的相同符号的个数 + 1，很简单很不讲道理，或许这就是贪心吧</p>
<p>简单感性理解一下为什么可以这样子, 我们单独看最长连续出现的相同符号这一段, 假设是 “&lt;&lt;&lt;&lt;” 那我们可以构造 “1&lt;2&lt;3&lt;4”, 其他的情况我们只需要或反向或正向的使用这一段里边的数字就可以了, 是一定一定可以用这几个数字填入其他所有的地方的</p>
<p>这个其实还是比较好理解的, 你脑子里自己想象一下</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> str[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> t;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">	<span class="keyword">while</span> (t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%d%s&quot;</span>, &amp;n, str);</span><br><span class="line">		<span class="type">char</span> last = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">		<span class="type">int</span> cnt = <span class="number">1</span>, ml = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (str[i] != last)</span><br><span class="line">			&#123;</span><br><span class="line">				ml = <span class="built_in">max</span>(ml, cnt);</span><br><span class="line">				last = str[i];</span><br><span class="line">				cnt = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				cnt++;</span><br><span class="line">		&#125;</span><br><span class="line">		ml = <span class="built_in">max</span>(ml, cnt);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ml + <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1838A/</url>
    <content><![CDATA[<h1 id="Blackboard-List"><a href="#Blackboard-List" class="headerlink" title="Blackboard List"></a>Blackboard List</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>在黑板上有两个数字，进行如下操作 $n-2$ 次：</p>
<ul>
<li>每次在黑板上选择任意两个数，将两个数的差的绝对值写在黑板上。</li>
</ul>
<p>这样你会得到一个长度为 $n (3 \le n \le 100)$ 的序列。</p>
<p>一共 $t (1 \le t \le 100)$ 组数据。</p>
<p>每组数据给定操作后的序列，需要你还原出最初写在黑板上的两个数。</p>
<p>虽然可能有多个答案，不过，你只需要输出其中任意一个可能中的一个数即可。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Two integers were written on a blackboard. After that, the following step was carried out $ n-2 $ times:</p>
<ul>
<li>Select any two integers on the board, and write the absolute value of their difference on the board.</li>
</ul>
<p>After this process was complete, the list of $ n $ integers was shuffled. You are given the final list. Recover one of the initial two numbers. You do not need to recover the other one.</p>
<p>You are guaranteed that the input can be generated using the above process.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 100 $ ) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 3 \le n \le 100 $ ) — the size of the final list.</p>
<p>The next line of each test case contains $ n $ integers $ a_1, a_2, \ldots a_n $ ( $ -10^9 \le a_i \le 10^9 $ ) — the shuffled list of numbers written on the blackboard.</p>
<p>It is guaranteed that the input was generated using the process described above.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output a single integer $ x $ — one of the two initial numbers on the blackboard.</p>
<p>If there are multiple solutions, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight tap"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">3</span><br><span class="line">9<span class="number"> 2 </span>7</span><br><span class="line">3</span><br><span class="line">15 -4 11</span><br><span class="line">4</span><br><span class="line">-9<span class="number"> 1 </span>11 -10</span><br><span class="line">5</span><br><span class="line">3<span class="number"> 0 </span>0<span class="number"> 0 </span>3</span><br><span class="line">7</span><br><span class="line">8<span class="number"> 16 </span>8<span class="number"> 0 </span>8<span class="number"> 16 </span>8</span><br><span class="line">4</span><br><span class="line">0<span class="number"> 0 </span>0 0</span><br><span class="line">10</span><br><span class="line">27<span class="number"> 1 </span>24<span class="number"> 28 </span>2 -1<span class="number"> 26 </span>25<span class="number"> 28 </span>27</span><br><span class="line">6</span><br><span class="line">600000000<span class="number"> 800000000 </span>0 -200000000<span class="number"> 1000000000 </span>800000000</span><br><span class="line">3</span><br><span class="line">0 -1000000000 1000000000</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">9</span><br><span class="line">11</span><br><span class="line"><span class="deletion">-9</span></span><br><span class="line">3</span><br><span class="line">8</span><br><span class="line">0</span><br><span class="line"><span class="deletion">-1</span></span><br><span class="line">600000000</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>记最开始给定的两个数是 $a$ 和 $b$, 首先我们要明确, 除了 $a$ 和 $b$ 之外, 其他的都只会是非负数, 所以如果有负数, 那么它肯定是 $a$ 和 $b$ 之一</p>
<p>剩下一种情况就是 $a$ 和 $b$ 都是非负数, 我们注意到一个性质, 当 $a$ 和 $b$ 均大于等于0的时候, $\left | a-b \right | $ 肯定要比 $a$ 和 $b$ 中较大的那个小, 由此不难推广到整个序列中任意一个构造出来的数都会比 $max(a,b)$ 要小, 那么整个序列中最大的数肯定就是 $a$ 和 $b$ 其中之一</p>
<p>综上, 我们直接把给定序列升序排列, 第一个是负数就输出第一个, 否则就输出最后一个</p>
<p>我居然想出来了, 看来刷题还是有点用的哈, 这要是放一开始我可能就去看答案了</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> a[<span class="number">110</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		<span class="built_in">sort</span>(a, a + n);</span><br><span class="line">		<span class="keyword">if</span>(a[<span class="number">0</span>] &lt; <span class="number">0</span>) cout &lt;&lt; a[<span class="number">0</span>] &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; a[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2023/10/13/CF1838B/</url>
    <content><![CDATA[<h1 id="Minimize-Permutation-Subarrays"><a href="#Minimize-Permutation-Subarrays" class="headerlink" title="Minimize Permutation Subarrays"></a>Minimize Permutation Subarrays</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>给定一个长度为 $n$ 的排列 $[p_1, p_2, …, p_n]$ ，任选两个元素（可以相同）并交换<strong>一次</strong>，使得其所有子段中排列（长度不一定为 $n$ ）的个数最少，输出被交换的元素的位置（下标从 $1$ 开始）。</p>
<p>对于样例 $1$ ，如果交换 $p_1$ 和 $p_2$ ，则可以得到排列 $ [2, 1, 3] $ ，含有 $3$ 个为排列的子段（ $ [1] $ , $ [2, 1] $ , $ [2, 1, 3] $ ）；</p>
<p>如果交换 $p_1$ 和 $p_3$ ，则可以得到排列 $ [3， 2， 1] $ ，含有 $3$ 个为排列的子段（ $ [1] $ , $ [2， 1] $ , $ [3， 2， 1] $ ）；</p>
<p>如果交换 $p_2$ 和 $p_3$ ，则可以得到排列 $ [1, 3, 2] $ ，含有 $2$ 个为排列的子段（ $ [1] $ ， $ [1, 3, 2] $ ）。</p>
<p>故当交换 $p_2$ 和 $p_3$ 时最优。</p>
<p>对于样例 $3$ ，交换第 $2$ 和第 $5$ 个元素后，得到 $[1, 4, 2, 5, 3]$ ，仅包含两个为排列的子段（ $[1]$ ， $[1, 4,, 2, 5, 3]$ ）。可以证明这是最优的情况。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given a permutation $ p $ of size $ n $ . You want to minimize the number of subarrays of $ p $ that are permutations. In order to do so, you must perform the following operation exactly once:</p>
<ul>
<li>Select integers $ i $ , $ j $ , where $ 1 \le i, j \le n $ , then</li>
<li>Swap $ p_i $ and $ p_j $ .</li>
</ul>
<p>For example, if $ p &#x3D; [5, 1, 4, 2, 3] $ and we choose $ i &#x3D; 2 $ , $ j &#x3D; 3 $ , the resulting array will be $ [5, 4, 1, 2, 3] $ . If instead we choose $ i &#x3D; j &#x3D; 5 $ , the resulting array will be $ [5, 1, 4, 2, 3] $ .</p>
<p>Which choice of $ i $ and $ j $ will minimize the number of subarrays that are permutations?</p>
<p>A permutation of length $ n $ is an array consisting of $ n $ distinct integers from $ 1 $ to $ n $ in arbitrary order. For example, $ [2,3,1,5,4] $ is a permutation, but $ [1,2,2] $ is not a permutation ( $ 2 $ appears twice in the array), and $ [1,3,4] $ is also not a permutation ( $ n&#x3D;3 $ but there is $ 4 $ in the array).</p>
<p>An array $ a $ is a subarray of an array $ b $ if $ a $ can be obtained from $ b $ by the deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases. The description of the test cases follows.</p>
<p>The first line of each test case contains a single integer $ n $ ( $ 3 \le n \le 2\cdot 10^5 $ ) — the size of the permutation.</p>
<p>The next line of each test case contains $ n $ integers $ p_1, p_2, \ldots p_n $ ( $ 1 \le p_i \le n $ , all $ p_i $ are distinct) — the elements of the permutation $ p $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 2\cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output two integers $ i $ and $ j $ ( $ 1 \le i, j \le n $ ) — the indices to swap in $ p $ .</p>
<p>If there are multiple solutions, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">3</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">5</span> <span class="number">6</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">7</span> <span class="number">6</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span> <span class="number">4</span> <span class="number">5</span> <span class="number">9</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">10</span> <span class="number">5</span> <span class="number">1</span> <span class="number">9</span> <span class="number">8</span> <span class="number">3</span> <span class="number">2</span> <span class="number">6</span> <span class="number">4</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">5</span> <span class="number">10</span> <span class="number">9</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">4</span> <span class="number">6</span> <span class="number">7</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span> <span class="number">5</span> <span class="number">7</span> <span class="number">10</span> <span class="number">1</span> <span class="number">8</span> <span class="number">6</span> <span class="number">4</span> <span class="number">9</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>要让子序列的个数最少. 题目要求一个合法的长度为 k 的子序列需要包含元素1到k, 且子序列需要是连续的一段</p>
<p>那么每个子序列肯定要从1开始吧, 然后下一个就要找2吧, 那如果1和2隔得很远, 比如1在开头, 2在结尾, 那么我们很明显就只有两个子序列, 一个是1, 另一个是1到n</p>
<p>所以第一反应是把1和2放到开头和结尾, 这样很明显子序列是最少的, 但是交换只能进行一次, 如果1和2都在中间, 我们没办法通过一次交换达到这个结果</p>
<p>我们再考虑别的方法, 例如子序列 <code>1 6 2</code>, 这肯定是不合法的吧, 因为我们在囊括1和2的时候包进去了一个比子序列长度大的数, 那我们不一定非要让1和2在开头和结尾, 我们只需要让最大的数在1和2中间即可</p>
<p>仔细解释一下, 因为任何长度大于二的子序列都需要2和1, 我们包含2和1的时候就肯定要包含最大的数n, 要让这个子序列合法, 我们就只能把整个序列包含进去才能合法, 这样子我们就只有两个子序列, 一个只有1, 一个有1到n, 就是最少的</p>
<p>具体方法是: </p>
<ul>
<li>如果1和2中间没有数字, 看看把1和n交换还是2和n能达到上述条件</li>
<li>如果1和2中间有别的数字, 选出最小的那个和 n 交换</li>
</ul>
<p><strong>注意</strong>: 不一定1就在左边2就在右边, 不要惯性思维</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="type">int</span> pos1, pos2, posmax;	<span class="comment">//记录1, 2, n的位置</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">			<span class="keyword">if</span>(a[i] == <span class="number">1</span>) pos1 = i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == <span class="number">2</span>) pos2 = i;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span>(a[i] == n) posmax = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>((pos1 &lt; posmax &amp;&amp; posmax &lt; pos2) || (pos2 &lt; posmax &amp;&amp; posmax &lt; pos1))	</span><br><span class="line">        <span class="comment">//别把n换出去就行 </span></span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; pos1 &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; pos2 &lt;&lt; endl;</span><br><span class="line">			<span class="keyword">continue</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(<span class="built_in">abs</span>(pos1 - pos2) == <span class="number">1</span>)	<span class="comment">//中间没有空位</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(posmax &lt; <span class="built_in">min</span>(pos1, pos2))</span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="built_in">min</span>(pos1, pos2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; posmax &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					cout &lt;&lt; <span class="built_in">max</span>(pos1, pos2) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; posmax &lt;&lt; endl;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="type">int</span> minn = <span class="number">1e9</span>, minpos = pos1;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> i = <span class="built_in">min</span>(pos1, pos2) + <span class="number">1</span>; i &lt; <span class="built_in">max</span>(pos1, pos2); i++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a[i] &lt; minn)</span><br><span class="line">				&#123;</span><br><span class="line">					minn = a[i], minpos = i;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			cout &lt;&lt; minpos &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; posmax &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>CF1838C</title>
    <url>/2023/09/17/CF1838C/</url>
    <content><![CDATA[<h1 id="No-Prime-Differences"><a href="#No-Prime-Differences" class="headerlink" title="No Prime Differences"></a>No Prime Differences</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>$n \times m$ 的网格，填入 $1,2,3,…,n \times m$，使得相邻的两个方格的差不是质数。</p>
<p>多组数据，输出任意一种方案（保证有解），每组输出间有空行（见样例）。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given integers $ n $ and $ m $ . Fill an $ n $ by $ m $ grid with the integers $ 1 $ through $ n\cdot m $ , in such a way that for any two adjacent cells in the grid, the absolute difference of the values in those cells is not a prime number. Two cells in the grid are considered adjacent if they share a side.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line of the input contains a single integer $ t $ ( $ 1 \le t \le 1000 $ ) — the number of test cases. The description of the test cases follows.</p>
<p>The first and only line of each test case contains two integers $ n $ and $ m $ ( $ 4 \le n, m \le 1000 $ ) — the dimensions of the grid.</p>
<p>It is guaranteed that the sum of $ n\cdot m $ over all test cases does not exceed $ 10^6 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output $ n $ lines of $ m $ integers each, representing the final grid. Every number from $ 1 $ to $ n\cdot m $ should appear exactly once in the grid.</p>
<p>The extra spaces and blank lines in the sample output below are only present to make the output easier to read, and are not required.</p>
<p>If there are multiple solutions, print any of them.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">4 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">7</span></span><br><span class="line"><span class="symbol">6 </span><span class="number">4</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">16</span>  <span class="number">7</span>  <span class="number">1</span>  <span class="number">9</span></span><br><span class="line"><span class="attribute">12</span>  <span class="number">8</span>  <span class="number">2</span>  <span class="number">3</span></span><br><span class="line"><span class="attribute">13</span>  <span class="number">4</span> <span class="number">10</span> <span class="number">11</span></span><br><span class="line"><span class="attribute">14</span>  <span class="number">5</span>  <span class="number">6</span> <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="attribute">29</span> <span class="number">23</span> <span class="number">17</span>  <span class="number">9</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">2</span></span><br><span class="line"><span class="attribute">33</span> <span class="number">27</span> <span class="number">21</span> <span class="number">15</span> <span class="number">11</span>  <span class="number">7</span>  <span class="number">1</span></span><br><span class="line"><span class="attribute">32</span> <span class="number">31</span> <span class="number">25</span> <span class="number">19</span> <span class="number">20</span> <span class="number">16</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">26</span> <span class="number">30</span> <span class="number">24</span> <span class="number">18</span> <span class="number">14</span>  <span class="number">8</span>  <span class="number">4</span></span><br><span class="line"><span class="attribute">35</span> <span class="number">34</span> <span class="number">28</span> <span class="number">22</span> <span class="number">13</span> <span class="number">12</span>  <span class="number">3</span></span><br><span class="line"></span><br><span class="line"> <span class="attribute">2</span>  <span class="number">3</span>  <span class="number">7</span> <span class="number">11</span></span><br><span class="line"> <span class="attribute">8</span>  <span class="number">9</span>  <span class="number">1</span> <span class="number">10</span></span><br><span class="line"><span class="attribute">17</span> <span class="number">13</span>  <span class="number">5</span>  <span class="number">4</span></span><br><span class="line"><span class="attribute">18</span> <span class="number">14</span>  <span class="number">6</span> <span class="number">12</span></span><br><span class="line"><span class="attribute">19</span> <span class="number">23</span> <span class="number">15</span> <span class="number">21</span></span><br><span class="line"><span class="attribute">20</span> <span class="number">24</span> <span class="number">16</span> <span class="number">22</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>构建一个 $n\times m$ 的矩阵</p>
<p>首先, 首先首先, <strong>1不是素数</strong>, 所以我们可以构建出以下这个矩阵</p>
<p>$\begin{matrix}<br>  &amp;1  &amp;2  &amp;3 &amp;4 \<br>  &amp;5  &amp;6  &amp;7 &amp;8 \<br>  &amp;9  &amp;10  &amp;11 &amp;12\<br>\end{matrix}$</p>
<p>这样子横向差都是1, 但是这样纵向差是 $m$, 如果 $m$ 是素数, 那这样子就寄了</p>
<p>那我们又想, 纵向差是 $m$ 不可以, 那么如果差是 $2\times m$ 不就可以了吗, 所以我们完全可以先按以上方法构造, 然后把奇数行凑一起输出, 把偶数行凑一起输出</p>
<p>有一点要注意的是, 先输出偶数行, 再输出奇数行, 可以避免出现纵向差为 $m$ 的情况, 如果先输出奇数行, 可能会出现第一行, 第三行, 第二行, 第四行的情况, 还是有可能出现纵向差是 $m$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="type">int</span> a[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n, m; cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">		<span class="type">int</span> num = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				a[i][j] = num++;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//先输出偶数行 </span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			cout &lt;&lt; endl;	</span><br><span class="line">		&#125; </span><br><span class="line">		<span class="comment">//再输出奇数行</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += <span class="number">2</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++)</span><br><span class="line">				cout &lt;&lt; a[i][j] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">			cout &lt;&lt; endl;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1839A</title>
    <url>/2023/09/17/CF1839A/</url>
    <content><![CDATA[<h1 id="The-Good-Array"><a href="#The-Good-Array" class="headerlink" title="The Good Array"></a>The Good Array</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>对于一个由 $0$ 和 $1$ 构成的数组 $a_1,a_2,\dots,a_n$，如果对于从 $1$ 到 $n$ 中所有的整数 $i$ 都满足以下两个条件，我们称这个数组为『好的数组』：</p>
<ul>
<li><strong>前</strong> $i$ 个元素中有至少 $\left\lceil\frac{i}{k}\right\rceil$ 个元素为 $1$；</li>
<li><strong>后</strong> $i$ 个元素中有至少 $\left\lceil\frac{i}{k}\right\rceil$ 个元素为 $1$。</li>
</ul>
<p>其中，$\left\lceil\frac{i}{k}\right\rceil$ 表示 $i$ 除以 $k$ 向上取整。</p>
<p>构造一个长度为 $n$ 的『好的数组』，使其中 $1$ 的数量尽可能的少。</p>
<h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>本题多测。第一行为一个整数 $t\left(1\le t\le10^4\right)$，表示有 $t$ 组数据。</p>
<p>接下来每组样例为一行，包含两个整数 $n,k\left(2\le n\le100,1\le k\le n\right)$，题目描述中已经给出。</p>
<h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>每组样例输出一行一个整数，表示你构造的『好的数组』中 $1$ 的数量。</p>
<h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>You are given two integers $ n $ and $ k $ .</p>
<p>An array $ a_1, a_2, \ldots, a_n $ of length $ n $ , consisting of zeroes and ones is good if for all integers $ i $ from $ 1 $ to $ n $ both of the following conditions are satisfied:</p>
<ul>
<li>at least $ \lceil \frac{i}{k} \rceil $ of the first $ i $ elements of $ a $ are equal to $ 1 $ ,</li>
<li>at least $ \lceil \frac{i}{k} \rceil $ of the last $ i $ elements of $ a $ are equal to $ 1 $ .</li>
</ul>
<p>Here, $ \lceil \frac{i}{k} \rceil $ denotes the result of division of $ i $ by $ k $ , rounded up. For example, $ \lceil \frac{6}{3} \rceil &#x3D; 2 $ , $ \lceil \frac{11}{5} \rceil &#x3D; \lceil 2.2 \rceil &#x3D; 3 $ and $ \lceil \frac{7}{4} \rceil &#x3D; \lceil 1.75 \rceil &#x3D; 2 $ .</p>
<p>Find the minimum possible number of ones in a good array.</p>
<h2 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>The only line of each test case contains two integers $ n $ , $ k $ ( $ 2 \le n \le 100 $ , $ 1 \le k \le n $ ) — the length of array and parameter $ k $ from the statement.</p>
<h2 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case output one integer — the minimum possible number of ones in a good array.</p>
<p>It can be shown that under the given constraints at least one good array always exists.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">7</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">5 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">3</span></span><br><span class="line"><span class="symbol">7 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">10 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">9 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">8 </span><span class="number">8</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">7</span><br><span class="line">4</span><br><span class="line">3</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们先只考虑前i个数字, 在1到k这一段, 我们需要1个1, 从k+1到2k这一段, 我们需要2个1…, 为了使每一段都合法, 那我们肯定要把1放在每一段的开头, 具体来说就是位置1放1, 位置k+1放1, 位置2k+1放1…</p>
<p>因为给的n很小, 我们完全可以先只按以上原则构造, 然后再从后往前遍历, 如果到一个位置发现1不够, 就在那个位置补1个就好了, 时间复杂度为 $O(n)$ </p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">110</span>;</span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="keyword">sizeof</span> a);	<span class="comment">//多例要清空</span></span><br><span class="line">		<span class="type">int</span> n, k; cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">		<span class="type">int</span> sum = <span class="number">0</span>;	<span class="comment">//记录目前放了几个1</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i += k)</span><br><span class="line">			a[i] = <span class="number">1</span>, sum++;</span><br><span class="line">		<span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)	<span class="comment">//从后往前遍历</span></span><br><span class="line">		&#123;</span><br><span class="line">			num += a[n - i + <span class="number">1</span>];	<span class="comment">//记录到目前位置一共有几个1</span></span><br><span class="line">			<span class="type">int</span> cod = (i % k &gt; <span class="number">0</span>) + i / k;	<span class="comment">//至少需要cod个1才合法</span></span><br><span class="line">			<span class="keyword">if</span>(num &lt; cod) sum++, num++;	<span class="comment">//在这个位置补1个1, num也要更新</span></span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1839B</title>
    <url>/2023/09/17/CF1839B/</url>
    <content><![CDATA[<h1 id="Lamps"><a href="#Lamps" class="headerlink" title="Lamps"></a>Lamps</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>有 $n$ 盏灯，每盏灯有不亮，亮，坏掉 3 种状态。一开始每盏灯都不亮。</p>
<p>第 $i$ 盏灯有属性 $a_i,b_i$。每次操作你可以选择一盏灭的灯将其点亮，并得到 $b_i$ 的分数。</p>
<p>每次操作结束后，记有 $x$ 盏灯亮着，则所有 $a_i \le x$ 的灯 $i$ 都会损坏（无论是否亮着）。</p>
<p>求能得到的最大分数。多组数据。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You have $ n $ lamps, numbered by integers from $ 1 $ to $ n $ . Each lamp $ i $ has two integer parameters $ a_i $ and $ b_i $ .</p>
<p>At each moment each lamp is in one of three states: it may be turned on, turned off, or broken.</p>
<p>Initially all lamps are turned off. In one operation you can select one lamp that is turned off and turn it on (you can’t turn on broken lamps). You receive $ b_i $ points for turning lamp $ i $ on. The following happens after each performed operation:</p>
<ul>
<li>Let’s denote the number of lamps that are turned on as $ x $ (broken lamps do not count). All lamps $ i $ such that $ a_i \le x $ simultaneously break, whether they were turned on or off.</li>
</ul>
<p>Please note that broken lamps never count as turned on and that after a turned on lamp breaks, you still keep points received for turning it on.</p>
<p>You can perform an arbitrary number of operations.</p>
<p>Find the maximum number of points you can get.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>The first line contains a single integer $ n $ ( $ 1 \le n \le 2 \cdot 10^5 $ ) — the number of lamps.</p>
<p>Each of the next $ n $ lines contains two integers $ a_i $ and $ b_i $ ( $ 1 \le a_i \le n, 1 \le b_i \le 10^9 $ ) — parameters of the $ i $ -th lamp.</p>
<p>It is guaranteed that sum of $ n $ over all test cases doesn’t exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, output one integer — the maximum number of points you can get.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">10</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">13</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">1</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">3</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">2</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">4</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">5</span></span><br><span class="line"><span class="symbol">2 </span><span class="number">3</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">15</span><br><span class="line">14</span><br><span class="line">20</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>当灯笼 $i$ 的 $a_i$ 小于等于目前亮着的灯笼个数 $x$ 的时候, 灯笼 $i$ 就会坏掉, 如果它没被点亮, 那么我们很明显就亏了 $b_i$ 的价值</p>
<p>而且很明显的是, $a_i$ 越小对 $x$ 的要求越高, 越容易浪费, 所以我们的思路就是一定要从小的 $a_i$ 开始点亮, 当 a_i 相同时, 我们要先点 $b_i$ 大的灯笼, 而且当一个灯笼被点亮之后坏掉了, 我们仍能保留价值, 且这个坏掉的灯笼不计入 $x$ </p>
<p>具体做法是: 对灯笼依据 $a_i$ 升序排列, 相同情况下 $b_i$ 大的放在前边, 然后我们遍历灯笼, 一个一个点亮, 用 <strong>队列</strong>存储自己点亮的灯笼的 $a_i$, 很明显队列中的 $a_i$ 也是非降序的</p>
<p>因为灯笼肯定是从 $a_i$ 小的开始坏起, 符合队列 <strong>先进先出</strong> 的性质, 每次遍历我们看看队头元素是否小于等于队列的长度, 然后一直弹出直到队头元素大于队列长度, 注意随着弹出队列长度显然</p>
<p>注意, 灯笼所有满足条件的同时坏掉的, 但是队列弹出长度会减小, 所以我们先要把长度存起来</p>
<p>对于 $a$ 是 3 3 3 3 3 3 3 的情况, 我们在点亮第三个灯笼的时候, 不仅队列中的三个灯笼要坏掉, 其他的 $a&#x3D;3$ 的灯笼也是要坏掉的, 我们不能只依靠队列的弹出来判断灯笼是否坏掉, 所以我们每次要记录最后一个弹出的元素的 $a$ 是多少, 代表着这个值的 $a$ 的灯笼是要坏掉的, 由于排序后 $a$ 满足非递减, 所以我们只需要判断即将要点亮的灯笼的 $a_i$ 是不是等于 $a$ 即可, 如果是就说明之前坏掉了, 是不能点亮的</p>
<p><strong>!</strong>: $a$ 和 $b$ 到了 $10^9$ , 无需多言, 开long long</p>
<p>在判断灯笼坏掉的部分, 因为每个灯笼最多也就进队出队一次, 这里的时间复杂度是 $O(n)$ 的, 不难看出总的时间复杂度是 $O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line">	ll a, b;</span><br><span class="line">&#125;c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(A p, A q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p.a == q.a) <span class="keyword">return</span> p.b &gt; q.b;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> p.a &lt; q.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		queue&lt;ll&gt; q;	<span class="comment">//存放已经开了的灯 </span></span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			cin &gt;&gt; c[i].a &gt;&gt; c[i].b;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">sort</span>(c + <span class="number">1</span>, c + n + <span class="number">1</span>, cmp);</span><br><span class="line">		ll ans = <span class="number">0</span>, tobreak = <span class="number">-1</span>;	<span class="comment">//tobreak代表也是要坏的灯笼</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			ll sz = q.<span class="built_in">size</span>(); </span><br><span class="line">			<span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				ll tmp = q.<span class="built_in">front</span>();</span><br><span class="line">				<span class="keyword">if</span>(tmp &gt; sz) <span class="keyword">break</span>;</span><br><span class="line">				tobreak = tmp, q.<span class="built_in">pop</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(c[i].a == tobreak) <span class="keyword">continue</span>;</span><br><span class="line">			ans += c[i].b;</span><br><span class="line">			q.<span class="built_in">push</span>(c[i].a);</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1839C</title>
    <url>/2023/09/17/CF1839C/</url>
    <content><![CDATA[<h1 id="Insert-Zero-and-Invert-Prefix"><a href="#Insert-Zero-and-Invert-Prefix" class="headerlink" title="Insert Zero and Invert Prefix"></a>Insert Zero and Invert Prefix</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>你有一个长度为 $n$ 的 01 序列 $a$，以及一个初始为空的序列 $b$。你接下来需要执行 $n$ 次操作，每次操作将会使序列 $b$ 的长度增加 $1$。</p>
<ul>
<li>在第 $i$ 次操作，你需要选择一个在 $[0,i)$ 之间的整数 $p$。然后在第 $p$ 位之后插入一个数字 $0$，并翻转之前的所有数字。</li>
<li>即，设在第 $i$ 次操作前的 $b$ 为 $b_1,b_2,…,b_{i-1}$。在第 $i$ 次操作选择在 $[0,i)$ 之间的整数 $p$，并使 $b$ 变为 $\overline{b_1}, \overline{b_2}, \ldots, \overline{b_{p}}, 0, b_{p+1}, b_{p+2}, \ldots, b_{i-1}$。其中，$\overline{x}$ 表示二进制翻转操作，即 $\overline{0}&#x3D;1,\overline{1}&#x3D;0$。</li>
</ul>
<p>对给定的数组 $a$，判断是否存在一组操作使得 $b$ 变为 $a$，若存在则输出方案。</p>
<p>多组数据。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>You have a sequence $ a_1, a_2, \ldots, a_n $ of length $ n $ , each element of which is either $ 0 $ or $ 1 $ , and a sequence $ b $ , which is initially empty.</p>
<p>You are going to perform $ n $ operations. On each of them you will increase the length of $ b $ by $ 1 $ .</p>
<ul>
<li>On the $ i $ -th operation you choose an integer $ p $ between $ 0 $ and $ i-1 $ . You insert $ 0 $ in the sequence $ b $ on position $ p+1 $ (after the first $ p $ elements), and then you invert the first $ p $ elements of $ b $ .</li>
<li>More formally: let’s denote the sequence $ b $ before the $ i $ -th ( $ 1 \le i \le n $ ) operation as $ b_1, b_2, \ldots, b_{i-1} $ . On the $ i $ -th operation you choose an integer $ p $ between $ 0 $ and $ i-1 $ and replace $ b $ with $ \overline{b_1}, \overline{b_2}, \ldots, \overline{b_{p}}, 0, b_{p+1}, b_{p+2}, \ldots, b_{i-1} $ . Here, $ \overline{x} $ denotes the binary inversion. Hence, $ \overline{0} &#x3D; 1 $ and $ \overline{1} &#x3D; 0 $ .</li>
</ul>
<p>You can find examples of operations in the Notes section.</p>
<p>Determine if there exists a sequence of operations that makes $ b $ equal to $ a $ . If such sequence of operations exists, find it.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>Each test contains multiple test cases. The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>The first line of each test case contains one integer $ n $ ( $ 1 \le n \le 10^5 $ ) — the length of the sequence $ a $ .</p>
<p>The second line of each test case contains $ n $ integers $ a_1, a_2, \ldots, a_n $ ( $ 0 \le a_i \le 1 $ ) — the sequence $ a $ .</p>
<p>It is guaranteed that the sum of $ n $ over all test cases does not exceed $ 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case:</p>
<ul>
<li>output “NO”, if it is impossible to make $ b $ equal to $ a $ using the given operations;</li>
<li>otherwise, output “YES” in the first line and $ n $ integers $ p_1, p_2, \ldots, p_n $ ( $ 0 \le p_i \le i-1 $ ) in the second line — the description of sequence of operations that makes $ b $ equal to $ a $ . Here, $ p_i $ should be the integer you choose on the $ i $ -th operation. If there are multiple solutions, you can output any of them.</li>
</ul>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">YES</span></span><br><span class="line"><span class="attribute">0</span> <span class="number">0</span> <span class="number">2</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="attribute">NO</span></span><br><span class="line"><span class="attribute">NO</span></span><br><span class="line"><span class="attribute">YES</span></span><br><span class="line"><span class="attribute">0</span> <span class="number">1</span> <span class="number">0</span> <span class="number">2</span> <span class="number">4</span> <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>要我们输出每次插入的位置</p>
<p>我们只能插入0, 所以1一定是靠取反得来的.</p>
<p>把插入0的位置之前的所有数取反, 要得到1, 1的右边一定要有0, 否则不可能, 换句话说就是如果 $a[n]&#x3D;1$, 肯定无解, 其他情况总能找到答案</p>
<p>那我们就来考虑构造方式, 取反会影响插入位置的左边的所有数, 那我们是不是要优先得到右边的1呢, 因为如果先得到了左边的1, 在去得到右边的1的时候, 肯定要在右边的位置插入, 而插入取反肯定会对已经得到的左边1造成影响</p>
<p>我们可以从右往左遍历, 把一段连续的0和连续的1当作一段来处理, 例如 111000 这样的当作一段, 如果是 001100, 那么最左边 00 是一段, 1100 是另一段, 我们从右往左遍历得到一些段, 然后我们优先处理靠右的段, 我们只需要在处理好的一段的最左边插入0, 就可以不影响已经构造好的段了</p>
<p>对于每一段而言, 我们得到的段肯定是一串连续1和一串连续0, 我们看在这一段中最右边的1出现在哪里, 然后我们就在这个位置右边记为 p 插入0即可, 所以我们完全可以一开始全插入在最左边插入, 然后最后一个0就插入在 p 就可以</p>
<p>不难看出, 总共的时间复杂度是 $O(n)$</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[N];	<span class="comment">//放一段一段的1和0</span></span><br><span class="line"><span class="type">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">			cin &gt;&gt; a[i];</span><br><span class="line">		<span class="keyword">if</span>(a[n])</span><br><span class="line">		&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;No\n&quot;</span>; <span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;YES\n&quot;</span>;</span><br><span class="line">		<span class="type">int</span> last = <span class="number">0</span>, idx = <span class="number">0</span>; <span class="comment">//idx表示有几段</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(last &amp;&amp; !a[i])	<span class="comment">//如果上一个是1但是这一个是0, 那说明进入了新的一段 </span></span><br><span class="line">			&#123;</span><br><span class="line">				idx++; </span><br><span class="line">			&#125;</span><br><span class="line">			v[idx].<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">			last = a[i];</span><br><span class="line">		&#125;</span><br><span class="line">		vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)</span><br><span class="line">		&#123;</span><br><span class="line">             <span class="comment">//r是最右边的1的位置, 如果没有1那么说明全是0, 那插入就要在最左边插入, 刚好就是0</span></span><br><span class="line">			<span class="type">int</span> sz = v[i].<span class="built_in">size</span>(), r = <span class="number">0</span>;	</span><br><span class="line">            <span class="comment">//因为是从右往左遍历塞入v, 所以还要翻转一下</span></span><br><span class="line">			<span class="built_in">reverse</span>(v[i].<span class="built_in">begin</span>(), v[i].<span class="built_in">end</span>());	</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(v[i][j] &amp;&amp; !v[i][j+<span class="number">1</span>])</span><br><span class="line">				&#123;</span><br><span class="line">					r = j + <span class="number">1</span>; <span class="keyword">break</span>;	<span class="comment">//找到这一段最右边的那个1的位置 </span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">//先放进去len-1个0, 插在开头位置 </span></span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; sz - <span class="number">1</span>; j++)</span><br><span class="line">			&#123;</span><br><span class="line">				ans.<span class="built_in">push_back</span>(<span class="number">0</span>); </span><br><span class="line">			&#125;</span><br><span class="line">			ans.<span class="built_in">push_back</span>(r);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">auto</span> &amp;item : ans) cout &lt;&lt; item &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="comment">//多例清空 </span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= idx; i++)</span><br><span class="line">			v[i].<span class="built_in">clear</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1841A</title>
    <url>/2023/09/17/CF1841A/</url>
    <content><![CDATA[<h1 id="Game-with-Board"><a href="#Game-with-Board" class="headerlink" title="Game with Board"></a>Game with Board</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>Alice 和 Bob 玩游戏，他们有一块黑板。最初，有 $n$ 个整数 $1$。Alice 和 Bob 轮流操作，Alice 先手。</p>
<p>轮到时，玩家必须在棋盘上选择几个（至少两个）相等的整数，擦除它们，然后写一个等于它们总和的新整数。</p>
<p>如果玩家不能移动（棋盘上的所有整数都不同），该玩家将赢得游戏。<br>如果两名选手都发挥最佳，则确定谁获胜。</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>Alice and Bob play a game. They have a blackboard; initially, there are $ n $ integers written on it, and each integer is equal to $ 1 $ .</p>
<p>Alice and Bob take turns; Alice goes first. On their turn, the player has to choose several (at least two) equal integers on the board, wipe them and write a new integer which is equal to their sum.</p>
<p>For example, if the board currently contains integers $ {1, 1, 2, 2, 2, 3} $ , then the following moves are possible:</p>
<ul>
<li>choose two integers equal to $ 1 $ , wipe them and write an integer $ 2 $ , then the board becomes $ {2, 2, 2, 2, 3} $ ;</li>
<li>choose two integers equal to $ 2 $ , wipe them and write an integer $ 4 $ , then the board becomes $ {1, 1, 2, 3, 4} $ ;</li>
<li>choose three integers equal to $ 2 $ , wipe them and write an integer $ 6 $ , then the board becomes $ {1, 1, 3, 6} $ .</li>
</ul>
<p>If a player cannot make a move (all integers on the board are different), that player wins the game.</p>
<p>Determine who wins if both players play optimally.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $ t $ ( $ 1 \le t \le 99 $ ) — the number of test cases.</p>
<p>Each test case consists of one line containing one integer $ n $ ( $ 2 \le n \le 100 $ ) — the number of integers equal to $ 1 $ on the board.</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print Alice if Alice wins when both players play optimally. Otherwise, print Bob.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br><span class="line">6</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Bob</span></span><br><span class="line"><span class="attribute">Alice</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>因为A先走, A有主动权, 我们看A能不能找到一个策略让自己必赢, 如果有那么A赢, 如果没有那么B赢, 所以这道题的理解很容易出错, 不明白题目所说的 “两人均发挥最佳” 是什么意思</p>
<p>A如果要赢, 就要让B无论如何选A都是赢的, 那么A可以在第一步的时候构造出 1 1 n-2 的情况, 然后B不得不选两个1去合, 合完之后 2 和 n-2 不一样, 肯定是A赢.</p>
<p>要让 2 和 n-2 不一样, n 要大于等于5, 那么也就是说 n 大于等于5的时候, A必赢</p>
<p>当n是2到4的时候, 推一下就知道无论A怎么选, 都是B赢</p>
<p>综上就可以总结出来了</p>
<p>感觉是一个好大的坑啊妈的</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>感觉这个代码写得好屈辱啊妈的</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">if</span>(n &gt;= <span class="number">5</span>) cout &lt;&lt; <span class="string">&quot;Alice\n&quot;</span>;</span><br><span class="line">		<span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Bob\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1841B</title>
    <url>/2023/09/17/CF1841B/</url>
    <content><![CDATA[<h1 id="Keep-it-Beautiful"><a href="#Keep-it-Beautiful" class="headerlink" title="Keep it Beautiful"></a>Keep it Beautiful</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>定义一个序列为好, 当且仅当我们能从头开始选一段序列(长度可以为0, 相对顺序不变)放到尾部的后边, 由此得到的新序列是非递减的, 注意当序列为空时, 这个序列也是好序列</p>
<p>初始时序列为空, 然后给你 $q$ 个数字, 按次序询问你对于当前这个数 $x$ 如果放到当前这个序列的尾部, 是否会破坏当前序列的<strong>好</strong>性质, 如果会就不选, 不会就可以选然后放到序列尾部变成一个新序列</p>
<p>要我们输出 $q$ 个数, 对应询问, 如果这个数你选了, 那么对应位置就是1, 否则就是0</p>
<p>比如你选了第1个数, 其他都没选, 那么就输出 1000000….0</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>The array $ [a_1, a_2, \dots, a_k] $ is called beautiful if it is possible to remove several (maybe zero) elements from the beginning of the array and insert all these elements to the back of the array in the same order in such a way that the resulting array is sorted in non-descending order.</p>
<p>In other words, the array $ [a_1, a_2, \dots, a_k] $ is beautiful if there exists an integer $ i \in [0, k-1] $ such that the array $ [a_{i+1}, a_{i+2}, \dots, a_{k-1}, a_k, a_1, a_2, \dots, a_i] $ is sorted in non-descending order.</p>
<p>For example:</p>
<ul>
<li>$ [3, 7, 7, 9, 2, 3] $ is beautiful: we can remove four first elements and insert them to the back in the same order, and we get the array $ [2, 3, 3, 7, 7, 9] $ , which is sorted in non-descending order;</li>
<li>$ [1, 2, 3, 4, 5] $ is beautiful: we can remove zero first elements and insert them to the back, and we get the array $ [1, 2, 3, 4, 5] $ , which is sorted in non-descending order;</li>
<li>$ [5, 2, 2, 1] $ is not beautiful.</li>
</ul>
<p>Note that any array consisting of zero elements or one element is beautiful.</p>
<p>You are given an array $ a $ , which is initially empty. You have to process $ q $ queries to it. During the $ i $ -th query, you will be given one integer $ x_i $ , and you have to do the following:</p>
<ul>
<li>if you can append the integer $ x_i $ to the back of the array $ a $ so that the array $ a $ stays beautiful, you have to append it;</li>
<li>otherwise, do nothing.</li>
</ul>
<p>After each query, report whether you appended the given integer $ x_i $ , or not.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains one integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>Each test case consists of two lines. The first line contains one integer $ q $ ( $ 1 \le q \le 2 \cdot 10^5 $ ) — the number of queries. The second line contains $ q $ integers $ x_1, x_2, \dots, x_q $ ( $ 0 \le x_i \le 10^9 $ ).</p>
<p>Additional constraint on the input: the sum of $ q $ over all test cases does not exceed $ 2 \cdot 10^5 $ ).</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print one string consisting of exactly $ q $ characters. The $ i $ -th character of the string should be 1 if you appended the integer during the $ i $ -th query; otherwise, it should be 0.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">7</span> <span class="number">7</span> <span class="number">9</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">1 </span><span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="symbol">3 </span><span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight dns"><table><tr><td class="code"><pre><span class="line"><span class="number">111110010</span></span><br><span class="line"><span class="number">11111</span></span><br><span class="line"><span class="number">11011</span></span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>我们先思考一下好序列有什么性质, 也就是说啥样的序列才可以通过把开头一段移到结尾实现非递减呢? </p>
<p>先声明下标从1开始</p>
<p>假设我们要把 1到p 这一段移到结尾, 那么新序列就是 <code>a[p+1], a[p+2],...,a[n], a[1], a[2],..., a[p]</code> , 如果满足非递减, </p>
<ol>
<li><p>那么首先毫无疑问的是 a[p+1] 是最小值, </p>
</li>
<li><p>然后 p+1到n 和 1到p 这两段都是有非递减性质, </p>
</li>
<li><p>且 a[n] 应该小于等于 a[1]</p>
</li>
</ol>
<p>然后我们就可以通过这个性质来面对 q 个询问了</p>
<p><strong>注意</strong>: 是否会破坏<strong>好</strong>性质, 是对于当前还没加入这个数的序列而言的, 不是让你所有一起考虑然后问你怎么样可以得到最长的好序列的, 我们只需要关注当前即可</p>
<p>当序列为空的时候, 随便加进来什么数都不会破坏<strong>好</strong>性质, 所以第一个数我们一定会加入序列</p>
<p>依据 性质2 这两段都要具有 <strong>非递减的单调性</strong>, 我们就可以来选数字了, 我们可以用 <strong>两个单调栈</strong> 来寻找正确答案, 一个栈代表 1到p 这一段记为 pre, 一个栈代表 p+1 到 n 这一段记为back</p>
<p>已知第一个数肯定要加入pre栈, 然后后边来的数如果大于等于pre栈栈顶元素, 就加入pre栈中, 直到遇到第一个小于pre栈栈顶元素的数, 那么毫无疑问, 这个数要放入back栈栈底, 然后pre栈就锁住了, 因为新来的只能放到序列尾部啊</p>
<p>在此之后, 入back栈的元素不仅要满足大于等于back栈栈顶, 还要满足 性质3, 也即是小于pre栈栈顶</p>
<p>我们栈存的是结构体, 结构体包含这个数的数值以及位置, 输出的时候我们根据栈中元素的位置输出的是1, 其他就是0</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">2e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> prett, bktt;</span><br><span class="line"><span class="type">int</span> ans[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> v, idx;</span><br><span class="line">&#125;pre[N], back[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		prett = bktt = <span class="number">0</span>;	<span class="comment">//多例清空 </span></span><br><span class="line">		<span class="type">int</span> n; cin &gt;&gt; n;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="type">int</span> a; cin &gt;&gt; a;</span><br><span class="line">			<span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				pre[++prett].v = a, pre[prett].idx = i;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span>(!bktt) <span class="comment">//如果后端栈为空 直接往前端塞 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a &gt;= pre[prett].v) pre[++prett].v = a, pre[prett].idx = i;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(a &lt;= pre[<span class="number">1</span>].v) back[++bktt].v = a, back[bktt].idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span>	<span class="comment">//如果后端栈不为空 不能再往前端栈塞了 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(a &gt;= back[bktt].v &amp;&amp; a &lt;= pre[<span class="number">1</span>].v)  back[++bktt].v = a, back[bktt].idx = i;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= prett; i++) ans[pre[i].idx] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= bktt; i++) ans[back[i].idx] = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cout &lt;&lt; ans[i];</span><br><span class="line">		cout &lt;&lt; endl;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) ans[i] = <span class="number">0</span>;	<span class="comment">//多例清空</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>CF1841C</title>
    <url>/2023/09/17/CF1841C/</url>
    <content><![CDATA[<h1 id="Ranom-Numbers"><a href="#Ranom-Numbers" class="headerlink" title="Ranom Numbers"></a>Ranom Numbers</h1><h2 id="题面翻译"><a href="#题面翻译" class="headerlink" title="题面翻译"></a>题面翻译</h2><p>Ranom Number 是一个字符串，这个字符串只含字母 $\texttt A \sim \texttt E$。$\texttt{A}$ 的值是 $1$，$\texttt{B}$ 的值是 $10$，$\texttt{C}$ 的值是 $100$，$\texttt{D}$ 的值是 $1000$，$\texttt{E}$ 的值是 $10000$。</p>
<p>这个串的值按如下规则计算：如果一个字母的右侧没有值<strong>严格大于</strong>它的字母，那么它对串的值贡献为正的该字母的值，否则贡献为负的该字母的值。一个串的值就是把所有字母的贡献加起来。</p>
<p>例如，$\texttt{DAAABDCA}$ 的值是 $ 1000 - 1 - 1 - 1 - 10 + 1000 + 100 + 1 &#x3D; 2088 $。</p>
<p>现在，给定一个 Ranom Number，你可以把它的<strong>不超过一个</strong>的字符改为其它的 $\texttt A \sim \texttt E$ 之间的字符，求你能得到的新 Ranom Number 的值最大可能是多少。</p>
<p>多组数据，输入串的总长度不超过 $2 \times 10^5$。</p>
<p>translated by 一扶苏一</p>
<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>No, not “random” numbers.</p>
<p>Ranom digits are denoted by uppercase Latin letters from A to E. Moreover, the value of the letter A is $ 1 $ , B is $ 10 $ , C is $ 100 $ , D is $ 1000 $ , E is $ 10000 $ .</p>
<p>A Ranom number is a sequence of Ranom digits. The value of the Ranom number is calculated as follows: the values of all digits are summed up, but some digits are taken with negative signs: a digit is taken with negative sign if there is a digit with a strictly greater value to the right of it (not necessarily immediately after it); otherwise, that digit is taken with a positive sign.</p>
<p>For example, the value of the Ranom number DAAABDCA is $ 1000 - 1 - 1 - 1 - 10 + 1000 + 100 + 1 &#x3D; 2088 $ .</p>
<p>You are given a Ranom number. You can change no more than one digit in it. Calculate the maximum possible value of the resulting number.</p>
<h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2><p>The first line contains a single integer $ t $ ( $ 1 \le t \le 10^4 $ ) — the number of test cases.</p>
<p>The only line of each test case contains a string $ s $ ( $ 1 \le |s| \le 2 \cdot 10^5 $ ) consisting of uppercase Latin letters from A to E — the Ranom number you are given.</p>
<p>The sum of the string lengths over all test cases does not exceed $ 2 \cdot 10^5 $ .</p>
<h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>For each test case, print a single integer — the maximum possible value of the number, if you can change no more than one digit in it.</p>
<h2 id="样例-1"><a href="#样例-1" class="headerlink" title="样例 #1"></a>样例 #1</h2><h3 id="样例输入-1"><a href="#样例输入-1" class="headerlink" title="样例输入 #1"></a>样例输入 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">DAAABDCA</span><br><span class="line">AB</span><br><span class="line">ABCDEEDCBA</span><br><span class="line">DDDDAAADDABECD</span><br></pre></td></tr></table></figure>

<h3 id="样例输出-1"><a href="#样例输出-1" class="headerlink" title="样例输出 #1"></a>样例输出 #1</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">11088</span><br><span class="line">10010</span><br><span class="line">31000</span><br><span class="line">15886</span><br></pre></td></tr></table></figure>

<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h4 id="写一下错误解法的经过"><a href="#写一下错误解法的经过" class="headerlink" title="写一下错误解法的经过"></a>写一下错误解法的经过</h4><p>刚开始我的做法是, 维护一个前缀和, 表示从1到位置x内有多少个A, B…., 然后又因为一个数右边有比他大的数, 那这个数就负贡献, 那就可以用dp的方式 $O(n)$ 求出每个位置右边的最大值, 然后先求出初始字符串的值, 具体就是根据每个位置右边最大值就可以得知是正还是负贡献. 然后我们枚举每一个位置, 将它换成其他四种字母, 我一开始想到一个数变大会让左边一些数字变负, 反之就会让左边一些数字变正, 刚好符合前缀和的性质, </p>
<p><strong>错就错在这里</strong>: 前缀和代表是位置1到x有多少个字母, 比如说左边有很多个C, 但是假设你把这个位置变小了, 假设从D变成C, 那之前的那些C就一定全部变正贡献吗? 要是这个位置的左边还有D, 还有E呢?</p>
<p>所以这个是错误的方法, 希望我可以从中学到一些经验, 下次不要再花这么多时间找bug</p>
<h5 id="以下是正确解法"><a href="#以下是正确解法" class="headerlink" title="以下是正确解法"></a>以下是正确解法</h5><p>贪心, <strong>感性理解</strong></p>
<p>首先我们要明确, 修改某个位置<strong>只可能对这个位置的左边有影响</strong>, 对右边是没有影响的</p>
<p>设要修改的字母种类是 $P$</p>
<ul>
<li>如果要把一个 $P$ 变大, 那么修改最左边的 $P$, 简单理解就是他所能影响的左区间最短, 因为变大肯定会让左边一些数由正变负, 我们肯定希望变负的数越少越好</li>
<li>如果要把 $P$ 变小, 那么修改最右边的 $P$, 因为 $P$ 变小肯定会让做左边的一些数由负变正, 我们肯定希望这样的数多一点, 就要让左区间尽可能大</li>
</ul>
<p>那我们就可以只修改每种字母的这两个位置, 暴力枚举一下把这两个位置换成别的字母的时候的得分, 最后求最大值就可以了</p>
<p>一共5种字母, 每种字母可以换成其他的4种字母, 求每种情况的得分需要 $O(n)$, 总共也就是 $O(5\times4\times n)$ </p>
<p><strong>注意</strong>: 多例要清空</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line">ll fp[<span class="number">5</span>], la[<span class="number">5</span>];</span><br><span class="line">ll sta[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">cal</span><span class="params">(string s)</span>	<span class="comment">//计算字符串代表的值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ll maxn = <span class="number">0</span>, sum = <span class="number">0</span>;	<span class="comment">//maxn是随着遍历的最大值值, 大于等于它就是正, 小于他就是负 </span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(s[i] - <span class="string">&#x27;A&#x27;</span> &gt;= maxn) sum += sta[s[i] - <span class="string">&#x27;A&#x27;</span>], maxn = s[i] - <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="keyword">else</span> sum -= sta[s[i] - <span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	ios::<span class="built_in">sync_with_stdio</span>(<span class="number">0</span>), cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> t; cin &gt;&gt; t;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">memset</span>(fp, <span class="number">-1</span>, <span class="keyword">sizeof</span> fp), <span class="built_in">memset</span>(la, <span class="number">-1</span>, <span class="keyword">sizeof</span> la);	<span class="comment">//-1表示还没出现</span></span><br><span class="line">		string s; cin &gt;&gt; s; </span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; s[i]; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span>(fp[s[i] - <span class="string">&#x27;A&#x27;</span>] == <span class="number">-1</span>) fp[s[i] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">			la[s[i] - <span class="string">&#x27;A&#x27;</span>] = i;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//暴力枚举即可</span></span><br><span class="line">		ll ans = <span class="number">-3e9</span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)	<span class="comment">//i代表要改的字母种类 </span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j ++)	<span class="comment">//j代表要改成什么 </span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span>(fp[i] != <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					string tmp = s;</span><br><span class="line">					tmp[fp[i]] = <span class="string">&#x27;A&#x27;</span> + j;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, <span class="built_in">cal</span>(tmp));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span>(la[i] != <span class="number">-1</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					string tmp = s;</span><br><span class="line">					tmp[la[i]] = <span class="string">&#x27;A&#x27;</span> + j;</span><br><span class="line">					ans = <span class="built_in">max</span>(ans, <span class="built_in">cal</span>(tmp));</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cout &lt;&lt; ans &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>用平方数表示X</title>
    <url>/2023/09/17/%E7%94%A8%E5%B9%B3%E6%96%B9%E6%95%B0%E8%A1%A8%E7%A4%BAX/</url>
    <content><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个数 $X$, 求最少加减多少个平方数可以得到 $X$</p>
<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>$t$ 个样例, 每行一个数 $X$</p>
<p>$t &#x3D; 100$, $X &#x3D; 10 ^{11}$</p>
<h2 id="输出s"><a href="#输出s" class="headerlink" title="输出s"></a>输出s</h2><p>$n$ 表示最少需要几个数, 然后跟着 $n$ 个数, 表示加减哪些数的平方数</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先我们考虑 $n&#x3D;1$ 的情况, 即 $X$ 是完全平方数, 那我们判断 sqrt(X) * sqrt(X) 是否等于 $X$ 即可</p>
<p>然后我们就很自然能想到<strong>平方差</strong>, 即考虑X是否能用 $A^2-B^2$ 表示呢?</p>
<p>我们知道如果可以, 就会有 $X&#x3D;A^2-B^2&#x3D;(A+B)(A-B)$ , 而 $(A+B)$ 和 $(A-B)$ 的差为2B, 是个偶数, 所以 $(A+B)$ 和 $(A-B)$ 是同奇偶性的, 换句话说, 如果一个数可以分解成两个同奇偶性的数的乘积, 那么它就可以用平方差来表示</p>
<p>那么什么样的数可以分解成两个同奇偶性的数的乘积呢?</p>
<p>当X为奇数的时候, 我们知道任何奇数都可以分解成两个奇数的乘积, 最简单的就是1乘以它自己, 所以所有奇数都可以用平方差表示, 排除那些完全平方数即可</p>
<p>当X为偶数的时候呢, 这里引入一个知识点: 偶数可以分成两类, 一类是4的倍数, 即 $4k$, 另一类是 $4k-2$. $4k-2&#x3D;2(k-1)$, 即奇数和2的乘积, 无论怎么分解, 2也会在其中一个因数中, 那个因数是偶数, 另一个就是奇数, 所以 $4k-2$ 类型的偶数肯定不能分解成两个奇偶性相同的因数, 也就不能用平方差表示; 而 $4k$ 类型的偶数, 肯定可以分出一个4出来, 而4又是$2\times2$, 这样 $4k$ 就是 $2\times2k$, 因数肯定是两个偶数, 所以 $4k$ 类型, 也即是4的倍数的偶数可以表示为 $A^2-B^2$</p>
<p>平方差考虑了, 我们还要考虑<strong>平方和</strong>的情况, 会不会 $X&#x3D;A^2+B^2$ 呢? 我们只需要枚举A, 看看有没有合法的B满足这个式子即可, 这一步时间复杂度是 $O(\sqrt{X})$ </p>
<p>如果上述情况都不满足, 也即是 $X$ 即不是奇数, 也不是4的倍数, 也不能用平方和来表示, 那此时 $X$ 一定是偶数, 让 $X\pm1^2$ 就可以得到一个奇数, 然后就可以用平方差表示</p>
<p>综上, 完全平方数是1步操作, 满足平方差或平方和是2步操作, 剩下均是3步操作</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2>]]></content>
      <categories>
        <category>题解</category>
      </categories>
      <tags>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
